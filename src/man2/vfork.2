." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "vfork" "2" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

.SH "Назва"
.PP

vfork — створити процес\-нащадок, блокуючи батьківський процес.

.SH "Синопсис"
.PP

.RS
.nf
 #include <sys/types.h>
 #include <unistd.h>
 pid_t vfork(void);

.fi
.RE

.SH "Стандартний опис"
.PP

\fI(З XPG4/SUSv2/чернетки POSIX)\fR Функція \fIvfork()\fR працює так само,
як і fork(), за винятком того, що її поведінка є невизначеною, якщо
процес, створений викликом \fIvfork()\fR, або змінює будь\-які дані, крім
змінної типу pid_t, в котрій зберігається значення, повернене
\fIvfork()\fR, або повертається з функції, в якій викликався \fIvfork()\fR,
або ж викликає будь\-яку іншу функцію перед тим, як успішно викликати
_exit (2) чи одну з функцій родини \fIexec\fR.

.SH "Помилки"
.PP

.TP
.B \fBEAGAIN\fR 
 забагато процесів — спробуйте ще.
.TP
.B \fBENOMEM\fR 
 недостатньо пам'яті підсисання (swap) для нового процесу.

.SH "Опис Linux"
.PP

\fBvfork\fR, як і fork (2), створює процес — нащадок
викликача. За подробицями й значеннями, що повертаються при цьому,
дивіться сторінку fork (2).

\fBvfork()\fR є особливим випадком clone (2). Його
використовують для створення нових процесів без копіювання таблиць
сторінок батьківського процесу. Він може бути корисним для чутливих до
швидкодії застосувань, де відбрунькований процес одразу ж викликає
execve (2). 

\fBvfork()\fR різниться від fork (2) тим, що батьківський
процес затримується, аж доки нащадок не викличе execve (2) 
чи _exit (2). Нащадок має спільну з батьком пам'ять,
включаючи стек, аж доки не викличе execve (2). Нащадок не
повинен повертатися з поточної функції чи викликати \fIexit()\fR, проте
може викликати \fI_exit()\fR.

Обробники сигналів, хоч і успадковуються, проте не є спільними. Сигнали
прибувають до батьківського процесу після того, як його відпустить
нащадок.

.SH "Історичний опис"
.PP

Під Linux \fIfork()\fR реалізовано при допомозі сторінок пам'яті, що
копіюються при запису до них — отже, ціною брунькування є лише
час і пам'ять, витрачені на створення копії батьківських таблиць
сторінок і унікальної структури задачі для нащадка. Однак, у погані
старі часи \fIfork()\fR міг вимагати повного копіювання цілого простору
даних викликача, часто без усякої потреби, бо зазвичай одразу ж після
того настає виклик \fIexec()\fR. Отож, для покращення швидкодії BSD
запропонували системний виклик \fBvfork\fR, котрий не копіював повністю
простір адрес батька, а позичав його пам'ять і потік керування аж до
виклику \fIexec()\fR чи виходу. Батьківський процес затримувався, доки
нащадок користувався його ресурсами. Використання \fBvfork\fR було
хитромудрим — наприклад, незмінність даних батьківського процесу
залежала від знання того, які змінні містяться в регістрах.

.SH "Вади"
.PP

Факт, що Linux оживив цього привида з минулого, є радше невтішним.
Сторінка підручника BSD заявляє: «Цей системний виклик буде
викоренено, коли реалізуються відповідні механізми системного розподілу.
Користувачам не слід залежати від семантики \fIvfork\fR, оскільки він у
цьому випадку стане синонімом для \fIfork\fR».

Висловлюючись формально, стандартний опис, поданий вище, не дозволяє
використовувати \fIvfork()\fR, бо наступний за ним \fIexec()\fR може
завершитись невдало, а що тоді повинно статись, не визначено.

Подробиці обробки сигналів туманні й різняться від системи до системи.
Сторінка підручника BSD говорить: «Для уникнення можливої
безвиході процесам, що відбрунькувались через \fIvfork\fR, ніколи не
надсилаються сигнали SIGTTOU чи SIGTTIN; радше, дозволяється виведення
чи \fIioctl\fR, а спроби введення завжди вказуватимуть кінець
файлу».

Наразі (Linux 2.3.25) strace (1) не може йти слідом за
\fIvfork()\fR і вимагає латки ядра.

.SH "Історія"
.PP

Системний виклик \fIvfork()\fR з'явився в 3.0BSD. В BSD 4.4 цей виклик
зроблено синонімом \fIfork()\fR, проте NetBSD ввела його знову, див.
http://www.netbsd.org/Documentation/kernel/vfork.html. В Linux
виклик був еквівалентний \fIfork()\fR до ядра 2.2.0\-pre6 чи десь так.
Починаючи з 2.2.0\-pre9 (на i386, на інших архітектурах дещо пізніше), це
— незалежний системний виклик. Підтримку додано до glibc 2.0.112.

.SH "Відповідність стандартам"
.PP

Виклик \fBvfork\fR може бути трохи подібним до викликів з такою самою
назвою в інших системах. Вимоги, накладені стандартами на \fBvfork\fR, є
слабшими, ніж вимоги щодо \fBfork\fR, тож реалізації, де ці два виклики
є синонімами — відповідні. Зокрема, програміст не повинен
вважати, що батьківський процес залишатиметься заблокованим аж до
виклику \fI_exit()\fR чи \fIexecve()\fR, а також не повинен покладатись не
якусь специфічну поведінку щодо спільної пам'яті.

.SH "Дивіться також"
.PP

clone (2), execve (2), fork(2), wait (2).

