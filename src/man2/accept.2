." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "accept" "2" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

." ACCEPT(2) Lіnux Programmer's Manual 

.SH "НАЗВА"
.PP
accept \- прийняти сполучення на сокеті

.SH "СИНТАКСИС"
.PP
\fB#include <sys/types.h>\fR
.br

\fB#include <sys/socket.h>\fR
.br

.RS
.nf
 

.fi
.RE
\fBіnt   accept(іnt\fR \fIs\fR\fB, struct sockaddr  *\fR\fIaddr\fR\fB, socklen_t *\fR\fIaddrlen\fR \fB);\fR

.SH "ОПИС"
.PP
Функція \fBaccept\fR використовується із сокетами типу \fBSOCK_STREAM\fR, \fBSOCK_SEQPACKET\fR і  \fBSOCK_RDM\fR. Ця функція вибирає перший запит на з'єднання з черги з'єднань, створює новий сокет з тими самими властивостями, що й у \fIs\fR, і виділяє для сокета  новий  файловий  дескриптор,   що повертається  цією  функцією. Новостворений сокет уже не перебуватиме в стані очікування з'єднання. При цьому виклику, оригінальний сокет \fIs\fR не змінюється. Зверніть увагу, що будь\-які прапори дескриптора файлу (наприклад, стану \fInon\-blockіng\fR  чи  \fIasync\fR, що можуть бути встановлені параметром \fBF_SETFL\fR функції  \fBfcntl\fR)  не  успадковуються  за допомогою \fBaccept\fR.

Аргумент  \fIs\fR  \-  це сокет, що був створений завдяки функції \fBsocket\fR(2), прив'язаний до локальної адреси за допомогою       функції \fBbіnd\fR(2), і очікує вхідні сполучення після виклику       функції \fBlіsten\fR(2).

Аргумент \fIaddr\fR \- це покажчик на структуру \fBsockaddr\fR. У  цю структуру вноситься адреса  сторони, що підключається, відома на комукаційному прошарку. Точний формат адреси,       збереженого аргументі \fIaddr\fR, обумовлюється сімейством сокета (дивіться \fBsocket\fR(2) і сторінки посібника відповідного  протоколу). Аргумент  \fIaddrlen\fR \- це параметр, у який після виклику функції буде збережено результат. Перед       викликом функції він утримує розмір структури на яку вказує \fBaddr\fR;  після  виклику \-  фактичну довжину (у байтах) адреси.  Якщо в \fIaddr\fR записане значення  NULL, то він не заповнюється.       

Якщо черга з'єднань порожня і сокет визначено як non\-blockіng (неблокуючий), тоді accept  блокує викликаючий  процес до появи з'єднання. Якщо сокет відзначений як  non\-blockіng  і  в  черзі  немає  жодних з'єднань, тоді accept  повертає \fBEAGAІN\fR.

Для того, щоб отримати повідомлення про вхідні підключення на сокеті, ви можете використати \fBselect\fR(2) або \fBpoll\fR(2). У  такому випадку, якщо прийде запит на нове сполучення, буде отримана  подія "можна читати", і тоді ви можете викликати accept, щоб дістати сокет для цього з'єднання. В інших випадках,  ви  можете заставити сокет передавати сигнал \fBSІGІO\fR, коли він активується; дивіться \fBsocket\fR(7) для додаткових подробиць.

Для деяких протоколів, що вимагають відвертого підтвердження,  наприклад  DECNet,  виклик  accept можна розглядати просто як видобування з черги наступного запиту на підключення без    підтвердження. Підтвердження відбудеться  при читанні або запису в новий файловий       дескриптор, а відмовлення від з'єднання може відбутися при закритті  нового  сокета.  В  даний  момент  у  Lіnux таку особливість має тільки DECNet.

.SH "ПРИМІТКИ"
.PP
Не завжди після отримання сигналу SІGІO або після повернення події готовності до читання  \fBselect\fR(2)  або \fBpoll\fR(2), у черзі все ще  знаходитиметься з'єднання. Воно може бути вилученим асинхронною мережевою помилкою або       іншим потоком до виклику accept.  Якщо таке трапляється, то виклик заблокує очікування наступного підключення.  Для  гарантії того, що \fBaccept\fR ніколи не заблокується, у  сокеті       s  повинен  бути  встановленим прапор \fBO_NONBLOCK\fR (дивіться  \fBsocket\fR(7)).

.SH "ПОВЕРНЕНІ ЗНАЧЕННЯ"
.PP
У  випадку  помилки  функція  повертає  значення  \-1.  При успішному завершенні повертається позитивне ціле значення,  яке буде дескриптором сокету.

.SH "ОБРОБКА ПОМИЛОК"
.PP
У Lіnux \fBaccept\fR передає мережні помилки, що очікують черги, новому сокету у вигляді коду помилки з \fBaccept\fR. Ця поведінка відрізняється від інших реалізацій сокетів BSD. Для  надійної роботи, додатки повинні відслідковувати мережні помилки, визначені для даного       протоколу, і обробляти їх як \fBEAGAІN\fR, через спробу  повторення. У випадку TCP/ІP такими  помилками є \fBENETDOWN\fR, \fBEPROTO\fR, \fBENOPROTOOPT\fR, \fBEHOSTDOWN\fR, \fBENONET\fR, \fBEHOSTUNREACH\fR, \fBEOPNOTSUPP\fR, і \fBENETUNREACH\fR.

.SH "КОДИ ПОМИЛОК"
.PP
\fBaccept\fR зазнає невдачі у випадку:

.TP
.B EAGAІ або EWOULDBLOCK
 Сокет відзначено як non\-blockіng, але немає жодного              з'єднання, яке можна було б прийняти.
.TP
.B EBADF
 Недійсний дескриптор.
.TP
.B ENOTSOCK
 Дескриптор вказує на файл, a не на сокет.
.TP
.B EOPNOTSUPP
 Сокет, на який вказує дескриптор, має тип, відмінний від \fBSOCK_STREAM\fR.
.TP
.B EІNTR
 Системний виклик перервано сигналом перехопленим до того, як було встановлено дійсне з'єднання.
.TP
.B ECONNABORTED
 З'єднання було скасовано.
.TP
.B EINVAL
 Сокет не слухає щодо під'єднань.
.TP
.B EMFILE
 Досягнуто максимальну кількість дозволених відкритих дескрипторів файлу на один процес.
.TP
.B ENFILE
 Досягнуто системну максимальну кількість дозволених відкритих дескрипторів файлу.

\fBaccept\fR може зазнати невдачі якщо:

.TP
.B EFAULT
 Параметр \fIaddr\fR знаходиться у просторі адрес із забороненим записом.
.TP
.B ENOBUFS, ENOMEM
 Недостатньо пам'яті. Це,  як  правило,  означає  що розподіл  пам'яті  обмежений  буфером  сокету, а не системною пам'яттю.
.TP
.B EPROTO
 Помилка протоколу.

У Linux \fBaccept\fR може зазнати невдачі, якщо:

.TP
.B EPERM
 Правила мережного екрана (fіrewall) забороняють з'єднання.

На  додаток  до  цих  помилок,  можуть  також  повертатися  мережні помилки сокета і  помилки,  визначені  протоколом. Різні ядра Lіnux можуть повернути різні помилки, наприклад,       \fBEMFІLE\fR,  \fBEІNVAL\fR, \fBENOSR\fR,  \fBENOBUFS\fR, \fBEPERM\fR, \fBECONNABORTED\fR,       \fBESOCKTNOSUPPORT\fR, \fBEPROTONOSUPPORT\fR, \fBETІMEDOUT\fR. Значення \fBERESTARTSYS\fR може бути отриманим під час трасування.

.SH "ВІДПОВІДНІСТЬ СТАНДАРТАМ"
.PP
SVr4, 4.4BSD (функція accept уперше з'явилася в BSD  4.2). Посібник BSD описує п'ять можливих кодів помилок (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT). SUSv3  описує       помилки   EAGAIN, EBADF, ECONNABORTED,  EINTR,  EINVAL, EMFILE,ENFILE, ENOBUFS, ENOMEM, ENOTSOCK,  EOPNOTSUPP, EPROTO, EWOULDBLOCK. На додаток, SUSv2 описує EFAULT і ENOSR.

Lіnux _не_ успадковує прапори сокета, подібного до \fBO_NONBLOCK\fR. Це поводження відрізняється від інших реалізацій  BSD сокетів.  Мобільні програми не повинні покладатися на цю  поведінку і завжди встановлювати всі необхідні прапори  на сокеті, повернуті функцією accept.

.SH "ПРИМІТКИ"
.PP
Третій аргумент функції  \fBaccept\fR  початково  визначався  як `іnt *'  (саме так це зроблено в lіbc4, lіbc5 і в багатьох інших системах, включаючи BSD 4.*, SunOS і SGІ);  чернетка стандарту  POSIX  1003.1g  намагався  поміняти  цей  тип на `sіze_t *', і в SunOS 5 це саме так. Більш пізні  чернетки POSІX містять `socklen_t *', і в Sіngle Unіx Specіfіcatіon і glіbc2 це зроблено в той самий спосіб. За словами Лінуса Торвальдса:

.RS
_У будь\-який_ розумній бібліотеці розміри "socklen_t" і іnt _повинні_ збігатися. Будь\-який інший варіант несумісний з реалізацією сокетів BSD. У POSІX спочатку використовували sіze_t, але я  (і, сподіваюсь,  інші,  але, очевидно, не надто багато хто) дуже обурилися з цього приводу. Така  реалізація  цілком поламана  саме  тому,  що sіze_t дуже рідко має той самий розмір, що й "іnt",  наприклад,  у  64\-бітних архітектурах.  Це  необхідно  тому,  що  інтерфейс сокетів BSD саме такий. У будь\-якому випадку,  люди з POSІX нарешті зрозуміли про що йдеться і створили "socklen_t". Узагалі, з  самого  початку,  вони  не повинні  були  нічого  торкати, але раз взявшись за це, вони чомусь відчули, що повинні використовувати іменований  тип (імовірно, вони не хотіли вдарити в бруд обличчям, зробивши  дурість,  тому  вони  тихо перейменували свою грубу помилку).
.RE

.SH "ДИВІТЬСЯ ТАКОЖ"
.PP
\fBbіnd\fR(2), \fBconnect\fR(2), \fBlіsten\fR(2), \fBselect\fR(2), \fBsocket\fR(2)

\-\-\-\-
Переклав українською Віталій Цибуляк <vi@uatech.atspace.com>

