." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "perlrequick" "1" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

." PERLREQUICK 1 2006-11-04 "perl v5.8.7" "Perl Programmers Reference Guide" 

.SH "Назва"
.PP
perlrequick \- ознайомлення з регулярними виразами Perl 

.SH "Опис"
.PP
Ця сторінка охоплює основи розуміння, створення і використання регулярних виразів ('рег. виразів') у Perl. 

.SS " Простий збіг зі словами. "
.PP

Найпростіший регулярний вираз \- це просто слово, або загальніше \- ланцюжок знаків. Регулярний вираз, що складається зі слова збіжиться з будь\-яким ланцюжком, що містить це слово: 

.RS
.nf
        "Hello World" =~ /World/;  # зійдеться

.fi
.RE
В цьому виразі, "World" являється рег. виразом, а "//", що оточують "/World/" вказують perl здійснити пошук по ланцюжку щодо співпадань. Оператор "=~" пов'язує ланцюжок із регулярним виразом і спричинить істинне значення, якщо рег. вираз зійшовся, або хибне \- якщо ні. В нашому випадку, "World" збіглося з другим словом з "Hello World", тож вираз виявиться істинним. Ця ідея має декілька варіацій. 

Вирази на зразок цього корисні для перевірки умов: 

.RS
.nf
        print "It matches\en" if "Hello World" =~ /World/;

.fi
.RE
Зміст порівняння можна обернути на протилежний за допомогою оператору "!~": 

.RS
.nf
        print "It doesn't match\en" if "Hello World" !~ /World/;

.fi
.RE
Літеральний ланцюжок регулярного виразу можна замінити на змінну: 

.RS
.nf
        $greeting = "World";
        print "It matches\en" if "Hello World" =~ /$greeting/;

.fi
.RE
Якщо ви порівнюєте із $_, то "$_ =~" частину можна опустити: 

.RS
.nf
        $_ = "Hello World";
        print "It matches\en" if /World/;
    print "It matches\en" if /World/; 

.fi
.RE
Нарешті, стандартні обмежувачі рег. виразу "//" можна поміняти на довільні, якщо додати 'm' (скорочення від 'match') напочатку: 

.RS
.nf
        "Hello World" =~ m!World!;   # обмежувач '!'
        "Hello World" =~ m{World};   # парні обмежувачі '{}'
        "/usr/bin/perl" =~ m"/perl"; # лапки як обмежувач,
                                     # '/' в ролі звичайного знаку

.fi
.RE
Регулярні вирази повинні *точно* співпасти з частиною ланцюжка, щоб вираз виявився істинним: 

.RS
.nf
         "Hello World" =~ /world/;  # не сходиться за регістром
         "Hello World" =~ /o W/;    # зійдеться, ' ' є звичайним символом
         "Hello World" =~ /World /; # не зійдеться, немає ' ' наприкінці

.fi
.RE
perl завжди спробує здійснити співпадання в найпершому можливому місці ланцюжка: 

.RS
.nf
        "Hello World" =~ /o/;       # збіглося з 'o' в 'Hello'
        "That hat is red" =~ /hat/; # зійшлося з 'hat' з 'That'

.fi
.RE
Не всі символи можна використати "такими, якими вони є" при порівнянні. Деякі знаки, названі *метазнаками*, резервовано для власних нотацій регулярних виразів. Метазнаками являються 

.RS
.nf
        {}[]()^$.|*+?\e

.fi
.RE
Співпадання із самим спеціальним знаком можна добитися, якщо попереду додати зворотній слеш: 

.RS
.nf
    "2+2=4" =~ /2+2/;       # не збігається, + є метазнаком     
    "2+2=4" =~   /2\e+2/;    # зійдеться, \e+ розглядається як
                            # звичний +     
    'C:\eWIN32' =~ /C:\e\eWIN/;                # зійдеться    
    "/usr/bin/perl" =~ /\e/usr\e/bin\e/perl/;  # зійдеться 

.fi
.RE
В останньому виразі, правий слеш '/' так само екрановано, оскільки він використовується як обмежувач регулярного виразу. 

Недруковні символи ASCII представлені керівними послідовностями. Спільними прикладами є "\et", що позначає табуляцію, "\en" \- знак нового рядка, "\er" \- повернення каретки тощо. Довільні байти можна представити вісімковими керівними послідовностями, наприклад "\e033", або шістнадцятковими, як от "\ex1B": 

.RS
.nf
        "1000\et2000" =~ m(0\et2)    # зійдеться
        "cat" =~ /\e143\ex61\ex74/    # зійдеться, хоч це й дивний спосіб
                                   # написання слова "cat" (кішка)

.fi
.RE
Регулярні вирази, в основному, розглядаються як привнесені в подвійні лапки ланцюжки, тож розкриття змінних працюватиме: 

.RS
.nf
        $foo = 'house';
        'cathouse' =~ /cat$foo/;   # зійдеться
        'housecat' =~ /${foo}cat/; # зійдеться

.fi
.RE
З усіма наведеними вище виразами, якщо збіг відбувся десь посередині ланцюжка, це вважатиметься вдалим порівнянням. Для того, щоб точніше вказати де саме повинно відбутися співпадання, нам потрібно скористатися опорних (закріплювальних) метазнаків "^" із "$". Опора "^" означає збіг на початку рядка, тоді як "$" \- на кінці, перед знаком нового рядка. Декілька прикладів: 

.RS
.nf
        "housekeeper" =~ /keeper/;         # зійдеться
        "housekeeper" =~ /^keeper/;        # не зійдеться
        "housekeeper" =~ /keeper$/;        # сходиться
        "housekeeper\en" =~ /keeper$/;      # сходиться
        "housekeeper" =~ /^housekeeper$/;  # сходиться

.fi
.RE

.SS " Класи знаків "
.PP
Клас знаків дозволяє вказати набір можливих знаків, а не тільки один. Класи вказуються за допомогою квадратних дужок "[...]" із набором імовірних знаків. Ось декілька прикладів: 

.RS
.nf
        /cat/;            # зійдеться з 'cat'
        /[bcr]at/;        # зійдеться з 'bat', 'cat' або 'rat'
        "abc" =~ /[cab]/; # зійдеться через 'a'

.fi
.RE
В останньому прикладі, навіть якщо 'c' стоїть першою в наборі класу, найпершим місцем, де регулярний вираз може зійтися з ланцюжком, є 'a'. 

.RS
.nf
         /[yY][eE][sS]/; # зіставити з 'yes' у регістро\-незалежний спосіб
                         # 'yes', 'Yes', 'YES' тощо
         /yes/i;         # так само зіставити з 'yes', не залежачи від
                         # регістру

.fi
.RE
В останньому прикладі показано порівнювання із зразком за використанням модифікатору 'i' (insensitive), що скасовує чутливість до регістру. 

Класи знаків так само включають звичайні знаки і спеціальні, але зміст набору спеціальних знаків усередині класу відрізняється від того, що використовуються ззовні. Спеціальними для класу вважаються "\-]\e^$" і буквального співпадання можна добитися за допомогою зворотнього слешу: 

.RS
.nf
        /[\e]c]def/; # збігається з ']def' or 'cdef'
        $x = 'bcr';
        /[$x]at/;   # збігається з 'bat, 'cat' і 'rat'
        /[\e$x]at/;  # зійдеться з '$at' і 'xat'
        /[\e\e$x]at/; # зійдеться з '\eat', 'bat, 'cat' і 'rat'

.fi
.RE
Спеціальний знак '\-' діє як оператор діапазону всередині класу знаків, тож незграбне "[0123456789]" і "[abc...xyz]" можна перетворити на струнке "[0\-9]" and "[a\-z]": 

.RS
.nf
         /item[0\-9]/;    # збігається з 'item0' аж до 'item9'
         /[0\-9a\-fA\-F]/;  # зійдеться з шістнадцятковим числом

.fi
.RE
Знак '\-' як перший або останній символ класу розглядається як звичайний знак. 

Спеціальний знак "^", якщо стоїть першим усередині класу, позначає заперечення цього класу знаків, що призведе до збігу з будь\-яким знаком *за винятком* тих, що включено в квадратні дужки. Обидва, "[...]" і "[^...]", повинні зійтися з якимось символом, інакше порівняння зазнає невдачі. Таким чином, 

.RS
.nf
        /[^a]at/;  # не зійдеться з 'aat' або 'at', зате
                   # із рештою, як от 'bat', 'cat, '0at', '%at' тощо.
        /[^0\-9]/;  # зійдеться із нечисловим символом
        /[a^]at/;  # зійдеться з 'aat' або '^at'; тут '^' звичайний

.fi
.RE
Perl включає декілька скорочень для загальних класів знаків: 

.TP
.B \ed
 позначає цифру, тотожно [0\-9] 

.TP
.B \es
 позначає пробіл, тотожно [\e \et\er\en\ef] 

.TP
.B \ew
 позначає символ, який може бути частиною слова (алфавітно\-числовий або _), тотожно [0\-9a\-zA\-Z_] 

.TP
.B \eD
 протилежний \ed; будь\-який символ окрім цифри, тотожно [^0\-9] 

.TP
.B \eS
 протилежний \es; будь\-який символ окрім пробілу, тотожно [^\es] 

.TP
.B \eW
 протилежний \ew; будь\-який символ окрім тих, що можуть складати слово, [^\ew] 

.TP
.B \e&.
 (крапка) збігається з будь\-яким знаком окрім \en 

Скорочення "\ed\es\ew\eD\eS\eW" можна вживати всередині і поза межами класу знаків. Ось декілька прикладів використання: 

.RS
.nf
        /\ed\ed:\ed\ed:\ed\ed/; # збігається з форматом часу гг:хх:сс
        /[\ed\es]/;         # збігається з будь\-якою цифрою або пробілом
        /\ew\eW\ew/;         # збігається зі знаком, що складатиме слово
                          # із наступним знаком, що не є частиною слова із
                          # наступним знаком слова
        /..rt/;           # збігається з будь\-якими двома знаками і 'rt'
        /end\e./;          # збігається з 'end.'
        /end[.]/;         # те саме, збігається з 'end.'

.fi
.RE
Опорний знак слова "\eb" збігається з межею між знаком, що складає слово і таким, що не може бути частиною слова, тобто "\ew\eW" або "\eW\ew": 

.RS
.nf
        $x = "Housecat catenates house and cat";
        $x =~ /\ebcat/;  # збігається з cat у 'catenates'
        $x =~ /cat\eb/;  # збігається з cat у 'housecat'
        $x =~ /\ebcat\eb/;  # збігається з 'cat' наприкінці ланцюжка

.fi
.RE
В останньому прикладі, кінець ланцюжка розглядається як обмежувач слова. 

.SS " Порівнювання з тим або іншим "
.PP
Ми можемо порівняти з різноманітними символьними ланцюжками за допомогою метасимволу альтернативи '|'. Щоб збіглося із "dog" або "cat", ми створимо рег. вираз "dog|cat". Як і раніше, Perl намагатиметься знайти збіг у найпершому можливому місці ланцюжка. В кожній позиції perl спочатку пробує зіставити з першою альтернативою "dog". Якщо "dog" не співпав, perl спробує тоді другу альтернативу "cat". Якщо "cat" також не збігається, тоді перевірка зазнає невдачі і perl переходить до наступної позиції в ланцюжкові. Декілька прикладів: 

.RS
.nf
        "cats and dogs" =~ /cat|dog|bird/;  # збігається з "cat"
        "cats and dogs" =~ /dog|cat|bird/;  # збігається з "cat"

.fi
.RE
Хоч "dog" і являється першою альтернативою в останньому регулярному виразі, "cat" вдається співпасти раніше в ланцюжку. 

.RS
.nf
        "cats"          =~ /c|ca|cat|cats/; # збігається з "c"
        "cats"          =~ /cats|cat|ca|c/; # збігається з "cats"

.fi
.RE
У поточній позиції знаку, перша ж альтернатива, яка призводить до збігу з регулярним виразом, буде тією, що співпала. В вищенаведеному прикладі, всі альтернативи підходять у першій позиції ланцюжка, але лише перша з альтернатив співпадає насправді. 

.SS " Групування речей і ієрархічне порівнювання "
.PP
Метасимвол групування "()" дозволяє розглянути частину регулярного виразу як єдине ціле. Окремі частини рег. виразу згруповано шляхом включення їх у круглі дужки. Регулярний вираз "house(cat|keeper)" означає збіг із "house" із наступним або "cat", або "keeper". Ще декілька прикладів: 

.RS
.nf
        /(a|b)b/;   # збігається з 'ab' або 'bb'
        /(^a|b)c/;  # збігається 'ac' на початку ланцюжка і 'bc' деінде
        /house(cat|)/;  # збігається з або 'housecat', або 'house'
        /house(cat(s|)|)/;  # збігається з або 'housecats', або 'housecat',
                            # або 'house'. Зверніть увагу, що групи можуть
                            # гніздитися
        "20" =~ /(19|20|)\ed\ed/;  # збігається з нульовою альтернативою
                                 # '()\ed\ed', оскільки '20\ed\ed' не співпадає

.fi
.RE

.SS " Звертання до збігів "
.PP
Метасимвол групування "()" також дозволяє здобуття частин ланцюжка, що зійшлися. Для кожної групи, частину, що збіглася, буде збережено в спеціальні змінні $1, $2 і.т.д. Їх можна застосовувати як звичайні змінні: 

.RS
.nf
        # добути години, хвилини, секунди
        $time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/;  # збігається з форматом гг:хх:сс
        $hours = $1;
        $minutes = $2;
        $seconds = $3

.fi
.RE
У першому контексті, збіг з "/рег. виразом/" з групуванням поверне список значень, що зійшлися "($1, $2,...)". Ми можемо змінити це на 

.RS
.nf
        ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);

.fi
.RE
Якщо групування в регулярному виразі гніздовано, $1 отримає групу з крайньою лівою відкриваючою дужкою, $2 з наступною відкриваючою дужкою тощо. Ось, наприклад, складний регулярний вираз і відповідні змінні, вказані нижче: 

.RS
.nf
        /(ab(cd|ef)((gi)|j))/;
         1  2      34

.fi
.RE
Зі змінними збігів $1, $2, ... пов'язані зворотні посилання (backrerefence) "\e1", "\e2", ... Зворотні посилання \- це змінні співпадань, які можна використати всередині регулярних виразів: 

.RS
.nf
        /(\ew\ew\ew)\es\e1/; # знайти послідовності на кшталт 'the the'
                        # в ланцюжкові

.fi
.RE
$1, $2, ... повинні використовуватись тільки поза межами регулярного виразу, тоді як "\e1", "\e2", ... \- тільки всередині. 

.SS " Повторення збігів "
.PP
Метасимволи\-квантори (кількісні метасимволи) "?", "*", "+" і "{}" дозволяють нам визначити число повторень частини регулярного виразу, який ми вважаємо, що збігся. Квантори додаються одразу після знаку, класу знаків або групи, які ми вказали. Вони означають наступне: 

.TP
.B "a?"
 збігтися з 'a' 1 або 0 разів 

.TP
.B "a*"
 збігтися з 'а' 0 або більше разів, тобто будь\-яку кількість разів 

.TP
.B "a+"
 збігтися з 'a' 1 або більше разів, тобто щонайменше один раз 

.TP
.B "a{n,m}"
 збігтися щонайменше "n" раз, але не більше ніж "m" раз 

.TP
.B "a{n,}"
 збігтися щонайменше "n" або більше разів 

.TP
.B "a{n}"
 збігтися точно "n" раз 

З наступними прикладами: 

.RS
.nf
        /[a\-z]+\es+\ed*/;  # зійдеться зі словом у нижньому регістрі,
                         # принаймні одним пробілом, і будь\-якою кількістю
                         # цифр
        /(\ew+)\es+\e1/;     # зійдеться з повтореним словом довільної довжини
        $year =~ /\ed{2,4}/;  # впевнитись, що $year складається з
                             # щонайменше 2 цифр, але не більше за 4
        $year =~ /\ed{4}|\ed{2}/;  # навіть краще; відкидає дати з 3\-ох цифр

.fi
.RE
Ці квантори спробують збігтися з найбільшою частиною ланцюжка, однак дозволяючи співпадання решти регулярного виразу. Таким чином, 

.RS
.nf
        $x = 'the cat in the hat';
        $x =~ /^(.*)(at)(.*)$/; # зійдуться
                                # $1 = 'the cat in the h'
                                # $2 = 'at'
                                # $3 = ''   (0 співпадань)

.fi
.RE
Перший квантор ".*" захватить якнайбільше ланцюжка, все ж дозволяючи збіг з регулярним виразом. Для другого квантору ".*" не залишилось ланцюжка, тож він не зійдеться. 

.SS " Інші порівняння "
.PP
Існує ще декілька речей, які вам цікаво би було знати про оператори збігів. 

Маючи код 

.RS
.nf
        $pattern = 'Seuss';
        while (<>) {
            print if /$pattern/;
        }

.fi
.RE
perl повинен оцінити $pattern (зразок) щоразу при проходженні через цикл. Якщо $pattern не міняється, використайте модифікатор "//o" для одноразового розкриття змінної. Якщо ви не бажаєте жодного розкриття змінних, скористайтеся спеціального роздільника "m''": 

.RS
.nf
        @pattern = ('Seuss');
        m/@pattern/; # збігається з 'Seuss'
        m'@pattern'; # збігається з буквальним ланцюжком '@pattern'

.fi
.RE
Глобальний модифікатор "//g" дозволяє регулярному виразу зійтися всередині ланцюжка стільки разів скільки можливо. В скалярному контексті, послідовні співпадання всередині ланцюжка спричинять перехід "//g" від одного збігу до іншого, запам'ятовуючи при цьому позицію в ланцюжкові. Ви можете отримати або встановити позицію за допомогою функції pos(). Наприклад, 

.RS
.nf
        $x = "cat dog house"; # 3 words
        while ($x =~ /(\ew+)/g) {
            print "Word is $1, ends at position ", pos $x, "\en";
        }

.fi
.RE
виводить 

.RS
.nf
        Word is cat, ends at position 3
        Word is dog, ends at position 7
        Word is house, ends at position 13

.fi
.RE
Порівнювання, що зазнало невдачі, або зміна ланцюжка поверне позицію до початкового значення. Якщо ви не хочете перезавантаження позиції після невдалого співпадання, скористуйтеся модифікатором "//c", як от "/рег. вираз/gc". 

В контексті списку, "//g" повертає список груп, що співпали, або якщо групування відсутнє \- список збігів із цілим регулярним виразом. Тож 

.RS
.nf
        @words = ($x =~ /(\ew+)/g);  # збігається,
                                    # $word[0] = 'cat'
                                    # $word[1] = 'dog'
                                    # $word[2] = 'house'

.fi
.RE

.SS " Пошук і заміна "
.PP
Пошук із заміною відбувається за схемою "s/рег. вираз/текст заміни/модифікатори". Текст заміни змістить те, що співпало з рег. виразом в ланцюжку. Оператор "=~" також застосовується тут для того, щоб пов'язати ланцюжок із дією "s///". Якщо порівнюється супроти $_, то вираз "$_ =~" можна опустити. При вдалім порівнянні, "s///" повертає число здійснених замін, у протилежному випадку \- хибно. Ось деякі приклади: 

.RS
.nf
        $x = "Time to feed the cat!";
        $x =~ s/cat/hacker/;   # $x міститиме "Time to feed the hacker!"
        $y = "'quoted words'";
        $y =~ s/^'(.*)'$/$1/;  # видалити одинарні лапки,
                               # $y міститиме "quoted words"
    

.fi
.RE
Із оператором "s///", змінні збігу $1, $2 і.т.д. одразу доступні для вжитку у виразі заміни. Додавши глобальний оператор, "s///g" шукатиме і замінить всі збіги з регулярним виразом в ланцюжку: 

.RS
.nf
        $x = "I batted 4 for 4";
        $x =~ s/4/four/;   # $x міститиме "I batted four for 4"
        $x = "I batted 4 for 4";
        $x =~ s/4/four/g;  # $x міститиме "I batted four for four"

.fi
.RE
Модифікатор обчислення "s///e" огортає ланцюжок заміни функцією "eval{...}" і обчислення візьме місце частини ланцюжка, що співпала з рег. виразом. Декілька прикладів: 

.RS
.nf
        # обернути всі слова в ланцюжку
        $x = "the cat in the hat";
        $x =~ s/(\ew+)/reverse $1/ge;  # $x міститиме "eht tac ni eht tah"
    
        # перетворити відсотки на десяткові числа
        $x = "A 39% hit rate";
        $x =~ s!(\ed+)%!$1/100!e;      # $x міститиме "A 0.39 hit rate"

.fi
.RE
Останній приклад демонструє, що "s///" може використати інші обмежувачі, такі як "s!!!" і "s{}{}", або навіть "s{}//". Якщо застосувати одинарні лапки "s'''", то рег. вираз і заміна вважатимуться ланцюжками, включеними в одинарні лапки. 

.SS " Оператор split "
.PP
"split /рег. вираз/, ланцюжок" розбиває ланцюжок на список з його частин і повертає цей список. Регулярний вираз визначає послідовність знаків, згідно з яким відбувається розбиття. Так, скажімо, щоб розбити ланцюжок на слова використайте 

.RS
.nf
        $x = "Calvin and Hobbes";
        @word = split /\es+/, $x;  # $word[0] = 'Calvin'
                                  # $word[1] = 'and'
                                  # $word[2] = 'Hobbes'

.fi
.RE
А щоб добути розділений комою список чисел: 

.RS
.nf
        $x = "1.618,2.718,   3.142";
        @const = split /,\es*/, $x;  # $const[0] = '1.618'
                                    # $const[1] = '2.718'
                                    # $const[2] = '3.142'

.fi
.RE
Якщо використати порожній регулярний вираз "//", ланцюжок буде розщеплено на окремі символи. Якщо ж регулярний вираз включає групування, тоді отриманий список міститиме також підланцюжки, що співпали: 

.RS
.nf
        $x = "/usr/bin";
        @parts = split m!(/)!, $x;  # $parts[0] = ''
                                    # $parts[1] = '/'
                                    # $parts[2] = 'usr'
                                    # $parts[3] = '/'
                                    # $parts[4] = 'bin'

.fi
.RE
Позаяк перший знак $x збігся з регулярним виразом, split додала порожній перший елемент до списку. 

.SH "Вади"
.PP
Жодних. 

.SH "Дивіться також"
.PP
Ця сторінка являється лише швидким введенням для початківців. Для глибшого ознайомлення з регулярними виразами зверніться до \fBperlretut\fR(1) і довідника \fBperlre\fR(1). 

Переклав українською Віталій Цибуляк.

