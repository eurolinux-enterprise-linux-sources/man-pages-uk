." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "gawk" "1" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

.SH "НАЗВА"
.PP
gawk \- мова пошуку й обробки зразків

.SH "СИНТАКСИС"
.PP
\fBgawk\fR [ опції POSIX або GNU ] \fB\-f\fR \fIпрограмний\fR\fB_\fR\fIфайл\fR [ \fB\-\-\fR ]
файл ...
.br

\fBgawk\fR [ опції POSIX або GNU ] [ \fB\-\-\fR ] \fIтекст\fR\fB_\fR\fIпрограми\fR файл ...
.br

\fBpgawk\fR [ опції POSIX або GNU ] \fB\-f\fR \fIпрограмний\fR\fB_\fR\fIфайл\fR [ \fB\-\-\fR ] файл ...
.br

\fBpgawk\fR [ опції POSIX або GNU ] [ \fB\-\-\fR ] \fIтекст\fR\fB_\fR\fIпрограми\fR файл ...
.br

.SH "ОПИС"
.PP
\fBGawk\fR \- це GNU втілення мови програмування AWK. Вона
відповідає визначенню мови, даному в Стандарті Команд, Мов і Знаряддь POSIX 1003.2 (Command
Language And Utilities Standard). Цей стандарт, у свою
чергу, заснований на книзі "Мова прогамування AWK" (The AWK Programming Language),
Aho, Kernighan і Weinberger. Крім того, у \fBgawk\fR внесені
деякі додаткові можливості, що з'явилися у версії \fBawk\fR для
UNIX System V Release 4. Підтримуються також пізніші
розширення \fBawk\fR, запропоновані Bell Laboratories, а також деякі
розширення GNU.

\fBPgawk\fR є профілюючою версією \fBgawk\fR. Вона схожа у всьому
до \fBgawk\fR, за виключенням того, що програми виконуються
повільніше і автоматично створюють профілюючий файл
виконання у \fIawkprof.out\fR. Дивіться опцію \fB\-\-profile\fR нижче.

Командний рядок складається з опцій до самої \fBgawk\fR,
AWK\-тексту програми (якщо не була вказано опціями \fB\-f\fR або
\fB\-\-file\fR) і значень, що можуть бути надані вбудованим
змінним \fBARGC\fR і \fBARGV\fR.

.SH "ФОРМАТ ОПЦІЙ"
.PP
Опції \fBgawk\fR можуть бути вказані як у традиційному для POSIX
однобуквеному форматі, так і у форматі довгих опцій GNU.
Опції POSIX починаються з "\fB\-\fR"\fB,\fR тоді як довгі опції
починаються з "\fB\-\-\fR"\fB.\fR Довгі опції надано для специфічних
для GNU можливостей, так і для стандартних можливостей
POSIX.

У відповідності зі стандартом POSIX, опції, специфічні для
\fBgawk\fR \fB,\fR повинні бути вказано як аргументи опції \fB\-W\fR. Може
бути вжито декілька опцій \fB\-W\fR. Для кожної опції \fB\-W\fR існує
відповідна довга опція (дивіться нижче). Аргументи довгих
опцій може бути приєднано знаком \fB=\fR (без пробілів), або
наступним аргументом командного рядка. Довгі опції можна
скорочувати, за умови що вони залишатимуться унікальними
назвами.

.SH "ОПЦІЇ"
.PP
\fBGawk\fR розуміє наступі опції (у алфавітному порядку).
.TP
.B \fB\-\-field\-separator\fR \fIfs\fR
 Використовувати \fIfs\fR як розділювач полів (значення вбудованої змінної \fBFS\fR).

.TP
.B \fB\-v\fR \fIзмінна\fR\fB=\fR\fIзначення\fR
.br
\fB\-\-assign\fR \fIзмінна\fR\fB=\fR\fIзначення\fR
 Присвоїти перед виконанням програми значення \fIзмінній\fR. Такі змінні будуть доступними у блоці \fBBEGINN\fR програми AWK.

.TP
.B \fB\-f\fR \fIпрограмний\fR\fB_\fR\fIфайл\fR
.br
\fB\-\-file\fR \fIпрограмний\fR\fB_\fR\fIфайл\fR
 Взяти текст програми з \fIпрограмного\fR\fB_\fR\fIфайлу\fR, замість з першого аргументу командного рядка. Може бути вказано кілька опцій \fB\-f\fR (або \fB\-\-file\fR).

.TP
.B \fB\-mf\fR \fINNN\fR
.br
\fB\-mr\fR \fINNN\fR
 Встановити різні обмеження пам'яті для значення \fINNN\fR. Прапор \fBf\fR встановлює максимальну кількість полів, а \fBr\fR \- максимальний розмір відрізку. Ці два прапорці і опцію \fB\-m\fR було введено в дослідницькій версії Bell Labs UNIX \fBawk\fR. Вони ігноруються \fBgawk\fR, оскільки \fBgawk\fR не має попередньо\-встановлених обмежень.

.TP
.B \fB\-W\fR \fBcompat\fR
.br
\fB\-W\fR \fBtraditional\fR
.br
\fB\-\-compat\fR
.br
\fB\-\-traditional\fR
 Працювати у режимі сумісності. У цьому режимі \fBgawk\fR працює як UNIX \fBawk\fR. Розширення GNU не підтримуються. Використанню \fB\-\-traditional\fR надається перевага перед іншими формами цієї опції. Додаткову інформацію ви знайдете нижче у розділі \fBРОЗШИРЕННЯ\fR \fBGNU\fR.

.TP
.B \fB\-W\fR \fBcopyleft\fR
.br
\fB\-W\fR \fBcopyright\fR
.br
\fB\-\-copyleft\fR
.br
\fB\-\-copyright\fR
 Вивести коротку інформацію про авторські права GNU і вийти.

.TP
.B \fB\-W\fR \fBdump\-variables\fR[\fB=\fR\fIfile\fR]
.br
\fB\-\-dump\-variables\fR[\fB=\fR\fIfile\fR]
 Надрукувати відсортований список глобальних змінних, їхніх типів і останніх значень до файлу \fIfile\fR. Якщо назву файлу не надано, \fBgawк\fR створить \fIawkvars.out\fR у поточному каталозі. Список всіх змінних є хорошим способом знайти типографічні функціями для певності що функції не використовують глобальні змінні, там де малися на увазі локальні.

.TP
.B \fB\-W\fR \fBexec\fR \fIfile\fR
.br
\fB\-\-exec\fR \fIfile\fR
 Схожа до \fB\-f\fR, за винятком того, що цю опцію буде оброблено останньою. Це повинно використовуватися зі \fB#!\fR скриптами CGI, щоб запобігти передаванню інших опцій або коду командного рядка з URL. Ця опція також унеможливлює надання значення змінним з командного рядка.

.TP
.B \fB\-W\fR \fBgen\-po\fR
.br
\fB\-\-gen\-po\fR
 Сканує і аналізує програму AWK, створюючи файл GNU \fB.po\fR формату на стандартному виводі, з входженнями для ланцюжків тексту, що можуть бути локалізованими у програмі. Сама програма не виконується. Дивіться дистрибуцію GNU \fBgettext\fR для додаткової інформації про файли \fB.po\fR.

.TP
.B \fB\-W\fR \fBhelp\fR
.br
\fB\-W\fR \fBusage\fR
.br
\fB\-\-help\fR
.br
\fB\-\-usage\fR
 Вивести коротеньку довідку про опції і вийти з успішним статусом.

.TP
.B \fB\-W\fR \fBlint\fR[\fB=\fR\fIаргумент\fR]
.br
\fB\-\-lint\fR[\fB=\fR\fIаргумент\fR]
 Видасть попередження про наявність сумнівних або несумісних з іншими втіленнями AWK конструкцій. Разом з необов'язковим аргументом \fBfatal\fR, призводить до фатальної помилки. Це, можливо радикально, але його використання сприяє розробці чистішого коду AWK. Разом з необов'язковим аргументом \fBinvalid\fR, тільки попередження про справді нечинні речі буде виведено.

.TP
.B \fB\-W\fR \fBlint\-old\fR
.br
\fB\-\-lint\-old\fR
 Видавати попередження про наявність конструкцій, несумісних зі старими версіями UNIX \fBawk\fR.

.TP
.B \fB\-W\fR \fBposix\fR
.br
\fB\-\-posix\fR
 Увімкнути \fIрежим\fR \fIсумісності\fR з наступними обмеженнями:

.br
  *  Екрануючі послідовності \fB\ex\fR не розпізнаватимуться. 
.br
  *  Якщо  значення \fBFS\fR \- один   пробіл, то роздільниками  вважаються  тільки  пробіл  ісимвол табуляції. Символ нового рядка роздільником не вважається.
.br
  *  Ви не зможете додавати рядки після \fB?\fR та \fB:\fR.
.br
  *  Не розпізнається синонім \fBfunc\fR ключового слова \fBfunction\fR.
.br
  *  Оператори \fB**\fR і \fB**=\fR не використовуються замість \fB^\fR і \fB^=\fR.
.br
  *  Недоступна функція \fBfflush()\fR.

.TP
.B \fB\-W\fR \fBprofile\fR[\fB=\fR\fIfile\fR]
.br
\fB\-\-profile\fR[\fB=\fR\fIfile\fR]
 Посилати профілюючі дані до \fIfile\fR. За замовчуванням \- \fIawkprof.out\fR. Коли використовується з \fBgawk\fR, профіль виглядатиме просто як "гарненько видрукуваний" програмний текст. Якщо використовується з \fBpgawk\fR, профіль втримуватиме номер виконання кожного виразу з лівого боку і число викликів кожної, означеної користувачем, функції.

.TP
.B \fB\-W\fR \fBre\-interval\fR
.br
\fB\-\-re\-interval\fR
 Дозволити використання інтервальних виразів  у регулярних виразах. (дивіться нижче). Інтервальні вирази традиційно були відсутні у мові AWK. Стандарт POSIX вніс їх для сумісності і одне з одним. Проте, їхнє використання може привести до помилок у роботі старих програм AWK, тому \fBgawk\fR розпізнає їх тільки, якщо надана ця опція або опція \fB\-\-posix\fR.

.TP
.B \fB\-W\fR \fBsource\fR \fIтекст\fR\fB_\fR\fIпрограми\fR
.br
\fB\-\-source\fR \fIтекст\fR\fB_\fR\fIпрограми\fR
 Використовувати \fIтекст\fR\fB_\fR\fIпрограми\fR як, власне, текст програми AWK. Ця опція дозволяє сполучати виклики бібліотечних функцій (підключаються через опції \fB\-f\fR і \fB\-\-file\fR) з вихідним кодом, що вводиться на командному рядку. Ця опція, в першу чергу, призначена для середнього і великого розміру програм AWK, використовуваних у скриптах оболонки.

.TP
.B \fB\-W\fR \fBversion\fR
.br
\fB\-\-version\fR
 Вивести інформацію про версію вашої копії \fBgawk\fR. Ця опція може бути корисною, якщо ви хочете довідатися, чи не застарів \fBgawk\fR, встановлений на вашій системі, а також якщо ви хочете повідомити про помилку. (У відповідність з GNU Coding Standards, ці опції приводять до негайного виходу з можливості обробки аргументів, що починаються з "\fB\-\fR", безпосередньо програмою AWK. Це відповідає угоді про обробку аргументів, використовуваній більшістю інших програм, сумісних зі стандартом POSIX.

У режимі сумісності всі інші опції вважаються невірними й ігноруються. У звичайному режимі, якщо вказано текст програми, невідомі опції передаються через масив \fBARGV\fR програмі AWK для обробки. Це дуже зручно для запуску програм через "\fB#!\fR".

.SH "ВИКОНАННЯ ПРОГРАМИ AWK"
.PP
Програми AWK складаються з послідовності операторів зразок\-дія і, необов'язкових, визначень функцій.

.RS
\fIшаблон\fR \fB{\fR \fIвирази\fR \fIдії\fR \fB}\fR
.br

.br
\fBfunction\fR \fIім'я\fR\fB(\fR\fIсписок\fR \fIпараметрів\fR\fB)\fR \fB{\fR \fIдії\fR \fB}\fR
.RE

Спочатку \fBgawk\fR читає вихідний текст програми з \fIпрограмного\fR\fB_\fR\fIфайлу\fR(\fIів\fR), якщо наданий, з аргументів опції \fB\-\-source\fR або з першого аргументу командного рядка, що не є опцією. Опції \fB\-f\fR і \fB\-\-source\fR можуть бути вказані на командному рядку кілька разів. \fBGawk\fR сприймає текст програми так, начебто всі \fIпрограмні\fR\fB_\fR\fIфайли\fR були зчеплені одне з одним. Це зручно також для створення бібліотек функцій AWK, тому що не вимагає явного визначення функцій у кожній новій програмі, що використовує їх. Крім того, ця можливість дозволяє сполучати бібліотечні функції з програмами командного рядка.

Змінна оточення \fBAWKPATH\fR містить шлях, по якому відбувається пошук файлів, вказаних опцією \fB\-f\fR. Якщо цієї змінної не існує, то типово, використовується шлях "\fI.:/usr/local/share/awk\fR". (Шлях може бути іншим, в залежності від того, як \fBgawk\fR було скомпільовано і встановлено.) Якщо назва файлу, вказаного як аргумент опції \fB\-f\fR, містить символ "\fB/\fR", то пошук не відбувається.

\fBGawk\fR виконує програми у наступній послідовності: спершу відбувається ініціалізація змінних, вказаних опцією \fB\-v\fR. Далі \fBgawk\fR компілює програму у внутрішній формат. Потім \fBgawk\fR виконує код у блоці (блоках) \fBBEGIN\fR, якщо такі існують, і починає читати файли, назви яких утримуються у масиві \fBARGV\fR. Якщо на командному рядку не було вказано жодних файлів, то \fBgawk\fR читатиме зі стандартного потоку вводу.

Якщо назва файлу на командному рядку має вигляд \fIvar\fR=\fIvall\fR, то воно сприймається як операція присвоєння. Змінній \fIvar\fR буде надано значення \fIvall\fR. (Це відбудеться одразу після виконання блоку (блоків) \fBBEGIN\fR.) Присвоювання значень способу розподілу вхідного потоку на поля і відрізки. Крім того, воно придатне в тих випадках, коли потрібно обробити кілька разів той самий файл.

Якщо значення одного з елементів \fBARGV\fR порожнє (\fB""\fR), \fBgawk\fR пропустить його.

Кожен відрізок вхідного потоку перевіряється \fBgawk\fR на предмет збігу з шаблонами. Для кожного шаблону, що збігсяз текстом, виконується відповідна дія. Перевірка шаблонів відбувається у тому самому порядку, в якому вони зустрічаються у програмі.

Нарешті, після того, як весь вхідний потік оброблено, \fBgawk\fR виконує код блоку (блоків) \fBEND\fR, якщо такі присутні.

.SH "ВІДРІЗКИ, ПОЛЯ І ЗМІННІ"
.PP
У AWK використовуються динамічні змінні, тобто, вони з'являться при першому їх використанні. Значенням змінних можуть бути числа з рухомою точкою, ланцюжки, або і те і інше, в залежності від їхнього використання. AWK також підтримує одновимірні масиви. Багатовимірні масиви можна імітувати. Під час виконання програми встановлюється декілька вбудованих змінних. Їх буде описано по ходу, з сумарним зведенням в кінці.

.SS "Відрізки"
.PP
Примітка: англійський термін \fIrecord\fR ми переклали як \fIвідрізок\fR, чим насправді він і є.

Стандартно, відрізки (records) розділяються символами нового рядка. Ви можете визначити відмінний спосіб поділу відрізків, якщо надасте нове значення вбудованій змінній \fBRS\fR. Якщо значенням \fBRS\fR є один символ, то він буде використовуватися для поділу відрізків. У протилежному випадку \fBRS\fR перетворюється у регулярний вираз. Текст серед
вхідного потоку, що збігся з цим виразом, буде розділяти окремі відрізки. У режимі сумісності, для поділу відрізків
буде використовуватися лише перший символ значення \fBRS\fR. Якщо \fBRS\fR встановлено як порожній ланцюжок, то відрізки будуть розділятися порожніми рядками. У цьому випадку, символ нового рядка працюватиме як роздільник полів, на
додаток до значення яке утримує \fBFS\fR.

.SS "Поля"
.PP
Кожний відрізковий запис, що зчитується, \fBgawk\fR розбиває на поля, використовуючи значення змінної \fBFS\fR як розділювач. Якщо значенням \fBFS\fR є один символ, то поля поділятимуться цим символом. Якщо значенням \fBFS\fR є порожній ланцюжок, то кожний символ вважатиметься окремим полем. У протилежному випадку, \fBFS\fR вважається регулярним виразом. Виключенням є випадок, коли значення \fBFS\fR встановлене до одного пробілу. В (Але дивіться також інформацію з \fB\-\-posix\fR нижче.) Зауважте: значення \fBIGNORECASE\fR (дивіться нижче) також впливає на те як відбувається поділ на поля, якщо \fBFS\fR є регулярним виразом, і на поділ відрізків, якщо \fBRS\fR є регулярним виразом.

Якщо змінна \fBFIELDWIDTHS\fR містить розділений пробілами список чисел, \fBgawk\fR вважатиме ширину кожного поля фіксованої довжини і розділятиме відрізки у відповідності зі вказаними сумарним числовим значенням. Значення змінної \fBFS\fR у цьому випадку ігнорується. Присвоювання нового значення змінній \fBFS\fR анулює використання \fBFIELDWIDTHS\fR і відновлює стандартне поводження.

На кожне поле вхідного відрізку можна посилатися за його позицією \- \fB$1\fR, \fB$2\fR і так далі. \fB$0\fR означає весь відрізок. Будь\-якому полю можна привласнити нове значення. Для посилань на поля необов'язково використовувати сталі. Наприклад:

.RS
.nf
 \fBn\fR \fB=\fR \fB5\fR
 \fBprint\fR \fB$n\fR

.fi
.RE
виведе п'яте поле відрізку. Змінна \fBNF\fR (number of fields) містить кількість полів вхідного відрізку.

Результатом посилання на неіснуюче поле (тобто поле з номером, що перевищує \fB$NF\fR) буде порожній ланцюжок. Присвоєння значення неіснуючому полю (наприклад, \fB$(NF+2)\fR \fB=\fR \fB5\fR) збільшує значення \fBNF\fR і створює проміжні поля з порожніми ланцюжками як значення, обчислює заново \fB$0\fR і використовує міст змінної \fBOFS\fR як розділювач полів. Посилання на поля з негативними номерами призведе до фатальної помилки. Зменшення значення \fBNF\fR викличе втрату значень полів з номерами, що перевищують нове значення. Значення \fB$0\fR буде обчислене заново, поля розділятимуться вмістом змінної \fBOFS\fR \fB.\fR

.SS "Вбудовані змінні"
.PP
Ось перелік вбудованих змінних \fBgawk\fR:

.TP
.B \fBARGC\fR
 Кількість аргументів командного рядка (за виключенням опцій \fBgawk\fR і назви файлу вихідного тексту програми).

.TP
.B \fBARGIND\fR
 Індекс масиву \fBARGV\fR, що вказує на оброблюваний у даний момент файл.

.TP
.B \fBARGV\fR
 Масив аргументів командного рядка. Індекс масиву може приймати значення від 0 до \fBARGC\fR \- 1. Змінюючи значення \fBARGV\fR, можна контролювати, які файли оброблятимуться.
.TP
.B \fBBINMODE\fR
 На несумісних з POSIX системах, вказує використання "бінарного" стану для всіх операцій вводу\-виводу над файлами. Числові значення 1, 2 або 3 визначають чи це стосується вхідних файлів, файлів виводу чи всіх файлів, відповідно. Букви \fB"r"\fR (read) або \fB"w"\fR (write) також означають файли вводу або виводу, тоді як \fB"rw"\fR або \fB"wr"\fR \- всі. Будь\-яке інше значення розглядатиметься як \fB"rw"\fR.

.TP
.B \fBCONVFMT\fR
 Формат перетворення чисел. За узгодженням, \fB"\fR \fB%.6g"\fR.

.TP
.B \fBENVIRON\fR
 Масив поточних значень змінних середовища. Масив індексовано назвами змінних, кожен елемент містячи значення відповідної змінної (наприклад, \fBENVIRON["HOME"]\fR може мати значення \fB/home/arnold\fR). Зміна вмісту цього масиву не впливає на значення змінних оточення, як їх бачать програми, що запускаються \fBgawk\fR за допомогою перенаправлення або функції \fBsystem()\fR.

.TP
.B \fBERRNO\fR
 Якщо виникла системна помилка під час перенаправлення для \fBgetline\fR, під час читання для \fBgetline\fR, або ж під час виклику \fBclose()\fR, те \fBERRNO\fR буде містити ланцюжок опису помилки. Це опис піддається перекладу у не\-англійських локалях.

.TP
.B \fBFIELDWIDTHS\fR
 Розділений пробілами, список довжин полів. Якщо цій змінній присвоюється нове значення, то \fBgawk\fR розділяє вхідні дані на поля фіксованої довжини, ігноруючи значення змінної \fBFS\fR.

.TP
.B \fBFILENAME\fR
 Назва файлу, оброблюваного в даний момент. Якщо на командному рядку не було вказано жодного файлу, то значення \fBFILENAME\fR дорівнюватиме "\fB\-\fR". У блоці \fBBEGIN\fR змінну \fBFILENAME\fR не визначено (хіба встановити її за допомогою \fBgetline\fR).

.TP
.B \fBFNR\fR
 Номер поточного відрізку в поточному файлі вводу.

.TP
.B \fBFS\fR
 Роздільник полів у вхідному потоці (field separator), за замовчуванням пробіл. Дивіться розділ \fBПоля\fR вище.

.TP
.B \fBIGNORECASE\fR
 Керує залежністю всіх регулярних виразів і ланцюжкових операцій від регістра. Якщо значення \fBIGNORECASE\fR не дорівнює нулеві, тоді регістр буде ігноровано у порівнюванню ланцюжків і регулярних виразах з \fB~\fR і \fB!~\fR, у вбудованих функціях \fBgensub()\fR, \fBgsub()\fR, \fBindex()\fR, \fBmatch()\fR, \fBsplit()\fR і \fBsub()\fR.
Таким чином, якщо значення \fBIGNORECASE\fR не дорівнює нулеві, то \fB/aB/\fR співпаде з будь\-яким ланцюжком з \fB"ab"\fR, \fB"a"\fR, \fB"Ab"\fR або \fB"AB"\fR. Як і у решті змінних AWK, початкове значення \fBIGNORECASE\fR дорівнює 0, тож усі операції з ланцюжками і регулярними виразами, за звичайних обставин, залежатимуть від регістру. У Unix, при ігноруванні регістру використовується повний набір символів ISO 8859\-1 Latin\-1. Починаючи з gawk 3.1.4, регістр літер повністю обізнаний з локаллю, основуючись на засоби з C \fI<ctype.h>\fR, такі як \fBisalpha()\fR і \fBtolupper()\fR.

.TP
.B \fBLINT\fR
 Надає динамічний контроль над опцією \fB\-\-lint\fR зсередини програми AWK.

.TP
.B \fBNF\fR
 Кількість полів у поточному відрізку (number of fields).

.TP
.B \fBNR\fR
 Загальна кількість відрізків (number of records), зустрінутих до даного моменту.

.TP
.B \fBOFMT\fR
 Формат виводу чисел (output format). За узгодженням, \fB"%.6g"\fR.

.TP
.B \fBOFS\fR
 Розділювач полів виводу (output field separator). За узгодженням, пробіл.

.TP
.B \fBORS\fR
 Розділювач відрізків виводу (output record separator). За узгодженням, символ нового рядка.

.TP
.B \fBPROCINFO\fR
 Члени цього масиву надають загальну інформацію про обіг програми AWK. На деяких системах, це можуть бути елементи \fBgroup1\fR по \fB"group\fR\fIn\fR\fB"\fR, де \fIn\fR буде номером додаткових груп процесу. Використайте оператор \fBin\fR щоб виявити ці елементи. Наступні елементи гарантовано присутні на вашій системі:

.br

.br
\fBPROCINFO["egid"]\fR Значення системного виклику \fBgetegid\fR(2).
.br
\fBPROCINFO["euid"]\fR Значення системного виклику \fBgeteuid\fR(2).
.br
\fBPROCINFO["FS"]\fR Містить ланцюжок \fB"FS"\fR, якщо відбувається розділення полів за допомогою \fBFS\fR, i \fB"FIELDWIDTHS"\fR, якщо відбувається розділення полів через \fBFIELWIDTHS\fR.
.br
\fBPROCINFO["gid"]\fR Значення системного виклику \fBgetgid\fR(2).
.br
\fBPROCINFO["pid"]\fR ID процесу.
.br
\fBPROCINFO["ppid"]\fR ID батьківського процесу.
.br
\fBPROCINFO["uid"]\fR Значення системного виклику \fBgetuid(2)\fR.
.br
\fBPROCINFO["version"]\fR Версія програми \fBgawk\fR. Цю змінну додано, починаючи з gawk 3.1.4.

.TP
.B \fBRS\fR
 Розділювач відрізків вводу (record separator). Типово, символ нового рядка.

.TP
.B \fBRT\fR
 Вказувач кінця відрізку (record terminator). \fBGawk\fR присвоїть \fBRT\fR значення вхідного тексту, що збіглося з символом або регулярним виразом, вказаним у \fBRS\fR.

.TP
.B \fBRSTART\fR
 Індекс першого символу, що збігся після виклику \fBmatch()\fR. 0, якщо збігу не було. (Це також означає
що індекси символів почнуться з 1.)

.TP
.B \fBRLENGTH\fR
 Довжина ланцюжка, що збіглася після виклику \fBmatch()\fR. \-1, якщо збігу не відбулося.

.TP
.B \fBSUBSEP\fR
 Символ, використовуваний для поділу індексів у масиві. Типово, "\e034".

.SS "Масиви"
.PP
Масиви індексуються за допомогою виразу в квадратних
дужками (\fB[\fR і \fB]\fR). Якщо цей вираз є списком (\fIвираз1\fR, \fIвираз2\fR, ...), то масив індексується ланцюжком, що складається зі зчеплених (ланцюжкових) значень усіх виразів, розділених значенням змінної \fBSUBSEP\fR. Ця можливість використовується для імітації багатовимірних масивів. Наприклад:

.RS
.nf
 \fBі = A ; j = B ; k = C\fR
 \fBx[і, j, k] = hello, world\en\fR

.fi
.RE
присвоює елементові масиву \fBx\fR, індексованого як \fB"A\e034B\e034C"\fR, ланцюжок \fB"hello,\fR \fBworld\en"\fR. Усі масиви в AWK асоціативні, тобто індексуються за ланцюжковим значенням.

Для перевірки, чи масив утримує певний індекс, можна використати спеціальний оператор \fBin\fR у \fBif\fR або \fBwhile\fR конструкціях:

.RS
.nf
 \fBif (val in array)\fR
 \fBprint array[val]\fR

.fi
.RE
перебирання всіх елементів масиву (ітерації).

Певний елемент може бути вилучено з масиву оператором \fBdelete\fR. Крім того, оператор \fBdelete\fR можна вжити для
видалення всього масиву. Для цього потрібно вказати назву масиву без індексу.

.SS "Типи змінних і їхнє перетворення"
.PP
Змінні і поля можуть бути числами (з рухомою точкою), ланцюжками, або і тим і іншим одночасно. Тип змінної залежить від контексту. У числових виразах змінна вважається числом, у ланцюжкових \- ланцюжковим типом.

Якщо ви хочете, щоб змінна вважалася числом, додайте до неї 0. Якщо, навпаки ланцюжком \- зчепіть її з порожнім
ланцюжком.

Перетворення ланцюжка у число відбувається за допомогою \fBstrtod\fR(3). Перетворення числа у ланцюжок \- за допомогою \fBsprintf\fR(3), використовуючи значення \fBCONVFMT\fR як ланцюжок форматування, з числовим значення змінної як  аргумент. Хоча всі числа в AWK вважаються числами з рухомою точкою, цілі значення завжди  перетворюються як цілі. Тому маючи

.RS
.nf
 \fBCONVFMT = %2.2f\fR
 \fBa = 12\fR
 \fBb = a\fR

.fi
.RE
ланцюжкове значення змінної \fBb\fR буде \fB"12"\fR, а не \fB"12.00"\fR.

\fBGawk\fR виконує порівнювання у такий спосіб: якщо дві змінні мають числове значення, то вони порівнюються як числа; якщо одна змінна має числове значення, а друга є ланцюжком, що містить число, то змінні теж порівнюються як числа. В усіх інших випадках, відбувається перетворення числа у ланцюжок, і змінні порівнюються як ланцюжки. Два ланцюжки, природньо, порівнюються як ланцюжки. Зауважте, що стандарт POSIX втілює принцип чисел\-ланцюжків скрізь, навіть з ланцюжковими константами. Це, безумовно, неправильно і \fBgawk\fR не слідує цьому. POSIX буде виправлено у наступній його версії.

Тож запам'ятайте, що ланцюжкові константи, такі як "57", \fIне\fR \fIє\fR "числами\-ланцюжками", а саме ланцюжковими константами. Термін "число\-ланцюжок" застосовується лише по відношенню до полів, вхідним даним \fBgetline\fR, елементам \fBFILENAME\fR, \fBARGV\fR, \fBENVIRON\fR і тих елементам масиву, створених \fBsplit()\fR, що також будуть числовими ланцюжками. Ідея полягає в тім, що в такий спосіб розглядається лише ввід користувача, що виглядає, як число.

Неініційовані змінні, якщо звернутися до них, матимуть Починаючи з 3.1 версії \fBgawk\fR, ви можете використовувати вісімкові і шіснадцяткові константи схожі на ті, що використовуються у C, у ваших програмах AWK. Так, наприклад, вісімкове значення 011 дорівнюватиме десятковому 9, тоді як шіснадцяткове 0x11 дорівнюватиме 17.

.SS "Ланцюжкові константи"
.PP
Ланцюжкові константи, або сталі, у AWK \- це послідовності знаків, включених у подвійні лапки ("). Всередині
ланцюжків розпізнаються певні екрановані послідовності, так само як і у C. А саме:

.TP
.B \fB\e\e\fR
 Буквальний зворотній слеш.

.TP
.B \fB\ea\fR
 Знак "alert" (тривога). Як правило, це знак BEL (дзвоник) набору символів ASCII.

.TP
.B \fB\eb\fR
 Знак повернення (відступу назад).

.TP
.B \fB\ef\fR
 Знак подання бланка (сторінки).

.TP
.B \fB\en\fR
 Знак нового рядка.

.TP
.B \fB\er\fR
 Знак повернення каретки.

.TP
.B \fB\et\fR
 Знак кроку табуляції.

.TP
.B \fB\ev\fR
 Знак вертикального кроку табуляції.

.TP
.B \fB\ex\fR\fIhex\fR
 Знак, що буде передано через шістнадцяткове число, що стоїть після \fB\ex\fR. Так само, як і в ANSII C, включені шістнадцядкові числа вважаються частиною екранованої послідовності. Наприклад, \fB"\ex1B"\fR відповідає ESC (знак перемикання коду) набору символів ASCII.

.TP
.B \fB\e\fR\fIddd\fR
 Знак, що буде передано через одно, двох або трьох\-значне вісімкове число. Наприклад, \fB"\e033"\fR відповідає ESC (знак перемикання коду) набору знаків ASCII.

.TP
.B \fB\e\fR\fIc\fR
 Буквальний знак \fIc\fR.

Екрановані послідовності також можуть використовуватись всередині регулярних виразів (наприклад, \fB/[\fR \fB\et\ef\en\er\ev]/\fR співпадатиме з знаками пробілів).

У стані сумісності, знаки, що передано як вісімкові або шістнадцяткові екрановані послідовності розглядаються
буквально при використанню у сталих регулярних виразів. Тобто, \fB/a\e52b/\fR рівнозначно \fB/a\e*b/\fR.

.SH "ШАБЛОНИ І ДІЇ"
.PP
AWK \- це рядково\-зорієнтована мова. Спершу вказується шаблон (порівнюється з відрізками), потім відповідна дія. Оператори дії включено у фігурні дужки \fB{\fR і \fB}\fR. Шаблон або дія можуть бути відсутніми, але, зрозуміло, не те й інше
одночасно. Якщо не вказано шаблон, то дія виконуватиметься для кожного вхідного відрізку. Пропущена ж дія рівнозначна виразу  

.RS
\fB{\fR \fBprint\fR \fB}\fR
.RE

тобто, виводить весь відрізок.

Коментарі починаються із символу "\fB#\fR" і продовжуються до кінця рядка вихідного коду. Для поділу тверджень можуть використовуватися порожні рядки. Звичайно, вислів закінчується кінцем рядка, крім випадків, коли рядки закінчуються символами "\fB,\fR", \fB{\fR, \fB?\fR, \fB:\fR, \fB&&\fR або \fB||\fR. Рядки, що закінчуються ключовими словами \fBdo\fR або \fBelse\fR \fB,\fR автоматично продовжуються на наступному рядку. В інших випадках, рядок може бути продовженим за допомогою символу "\fB\e\fR", при цьому символ нового рядка екранується і буде ігноровано.

Декілька, тверджень на одному рядку, повинні бути розділені символом "\fB;\fR". Це відноситься як до виразів дії пари шаблон\-дія (типовий випадок), так і до самих пар шаблон\-дія.

.SS "Шаблони"
.PP
Зразки AWK можуть бути наступними:

.RS
\fBBEGIN\fR
.br

.br
\fBEND\fR
.br

.br
\fB/\fR\fIрегулярний\fR \fIвираз\fR\fB/\fR
.br

.br
\fIумовний\fR \fIвираз\fR
.br

.br
\fIшаблон\fR \fB&&\fR \fIшаблон\fR
.br

.br
\fIшаблон\fR \fB||\fR \fIшаблон\fR
.br

.br
\fIшаблон\fR \fB?\fR \fIшаблон\fR \fB:\fR \fIшаблон\fR
.br

.br
\fB(\fR\fIшаблон\fR\fB)\fR
.br

.br
\fB!\fR \fIшаблон\fR
.br

.br
\fIшаблон1\fR\fB,\fR \fIшаблон2\fR
.br

.RE

\fBBEGIN\fR і \fBEND\fR являються двома спеціальними зразками, які не перевіряються на збіг із вхідними даними. Дії всіх шаблонів \fBBEGIN\fR поєднуються, начебто всі твердження було вказано в одному блоці \fBBEGIN\fR. Вказівки з цих блоків виконуються перед читанням будь\-яких вхідних даних. Схожим чином поєднуються всі вирази \fBEND\fR і виконуються після того як не залишилось жодного вводу (або після виконання \fBexit\fR).
Зразки з \fBBEGIN\fR і \fBEND\fR не можуть бути об'єднаними з іншими шаблонами. Дії у шаблонах \fBBEGIN\fR та \fBEND\fR обов'язково повинні бути вказаними.

Дії, прив'язані до шаблонів \fB/\fR\fIрегулярний вираз\fR\fB/\fR, виконуються  для всіх вхідних відрізків, що збіглися з цим  регулярним виразом. Правила регулярних виразів співпадають з описаними в \fBegrep\fR(1); швидкий огляд ви знайдете нижче.

\fIУмовні\fR \fIвирази\fR можуть складатися з будь\-яких операторів, описаних нижче у розділі, присвяченому діям. Загалом, вони перевіряють чи певні поля співпадають з певними регулярними виразами.

Оператори \fB&&\fR, \fB||\fR і \fB!\fR \- це логічні І, АБО та НІ, відповідно. Ці оператори застосовуються для об'єднання простіших шаблонів. (Схоже до C, вони здійснюють короткі обчислення логічних виразів.) Як і в більшості мов, для зміни черги обчислень можуть застосовуватися круглі дужки.

Оператор \fB?:\fR відповідає тому самому операторові з C. Якщо перший шаблон справдився, то для перевірки використовується другий шаблон, у протилежному випадку \- третій. Обчислюється тільки другий або тільки третій шаблон.

Вирази на зразок \fIшаблон1\fR, \fIшаблон2\fR називаються \fIшаблонами\fR \fIдіапазону\fR. Вони збігаються з усіма відрізками, починаючи з відрізку, що співпав з \fIшаблоном1\fR, і закінчуючи тим, що співпав із \fIшаблоном2\fR, включно. Цей шаблон не може бути об'єднано з жодним іншим.

.SS "Регулярні вирази"
.PP
Регулярні вирази AWK \- це розширена версія регулярних виразів \fBegrep\fR. Вони складаються з наступних символів:

.TP
.B \fIc\fR
 збігається з не\-метасимволом \fIc\fR.
.TP
.B \fB\e\fR\fIc\fR
 збігається з буквальним символом \fIc\fR.
.TP
.B \fB.\fR
 збігається з будь\-яким символом, \fIвключаючи\fR символ нового рядка.
.TP
.B \fB^\fR
 збігається з початком рядка.
.TP
.B \fB$\fR
 збігається з кінцем рядка.
.TP
.B \fB[\fR\fIabc...\fR\fB]\fR
 список символів, збігається з будь\-яким одним символом з \fIabc...\fR.
.TP
.B \fB[^\fR\fIabc...\fR\fB]\fR
 негативний список символів, збігається з будь\-яким символом, крім \fIabc...\fR.
.TP
.B \fIr1\fR\fB|\fR\fIr2\fR
 чергування: збігається або з \fIr1\fR, або з \fIr2\fR.
.TP
.B \fIr1r2\fR
 зчеплення: збігається спершу з \fIr1\fR, потім з \fIr2\fR.
.TP
.B \fIr\fR\fB+\fR
 збігається з одним або більше \fIr\fR.
.TP
.B \fIr\fR\fB*\fR
 збігається з нуль або більше \fIr\fR.
.TP
.B \fIr\fR\fB?\fR
 збігається з нуль або одним \fIr\fR.
.TP
.B \fB(\fR\fIr\fR\fB)\fR
 групування: збігається з \fIr\fR.
.TP
.B \fIr\fR\fB{\fR\fIn\fR\fB}\fR
.br
\fIr\fR\fB{\fR\fIn\fR\fB,}\fR
.br
\fIr\fR\fB{\fR\fIn\fR\fB,\fR\fIm\fR\fB}\fR
 Одне або два числа у фігурних дужках позначають інтервальний вираз. Якщо в дужках вказане одне розділених комою, то \fIr\fR повинен повторюватись від \fIn\fR до \fIm\fR раз. Якщо вказано тільки одне з комою, то \fIr\fR повторюється, щонайменше, \fIn\fR разів. Інтервальні вирази можна використовувати, лише якщо на командному рядку було вказано або опцію \fB\-\-posix\fR, або \fB\-\-re\-interval\fR.
.TP
.B \fB\ey\fR
 збігається з порожнім ланцюжком на початку або наприкінці слова.
.TP
.B \fB\eB\fR
 збігається з порожнім ланцюжком у слові.
.TP
.B \fB\e<\fR
 збігається з порожнім ланцюжком на початку слова.
.TP
.B \fB\e>\fR
 збігається з порожнім ланцюжком наприкінці слова.
.TP
.B \fB\ew\fR
 збігається з будь\-яким символом "слова" (буква, цифра або твердий пробіл).
.TP
.B \fB\eW\fR
 збігається з будь\-яким символом, крім тих що складають "слово".
.TP
.B \fB\e`\fR
 збігається з порожнім ланцюжком на початку буфера.
.TP
.B \fB\e'\fR
 збігається з порожнім ланцюжком наприкінці буфера.

Всі екрануючі послідовності, дійсні у ланцюжкових константах (дивіться нижче), можуть вживатися також у регулярних виразах.

\fIКласи\fR \fIсимволів\fR \- нова риса, привнесена стандартом POSIX. Клас символів \- це спеціальна система позначень списків символів, що мають певну спільну ознаку. Одночасно, самі символи списку для різних країн і/або для різних наборів символів (кодувань) можуть відрізнятись. Так наприклад, поняття що являє собою символ алфавіту, може розрізнятися для США і Франції.

Класи символів дійсні в регулярних виразах лише всередині квадратних дужок, які ми використовуємо для списку символів. Клас символів складається з \fB[:\fR, ключового слова, що позначає клас, і \fB:]\fR. Нижче наведені класи символів, визначені стандартом POSIX: 

.TP
.B \fB[:alnum:]\fR
 Буквено\-цифрові символи (буква, цифра, твердий пробіл).

.TP
.B \fB[:alpha:]\fR
 Алфавітні символи.

.TP
.B \fB[:blank:]\fR
 Символи пробілу або табуляції.

.TP
.B \fB[:cntrl:]\fR
 Керуючі символи.

.TP
.B \fB[:digit:]\fR
 Цифри.

.TP
.B \fB[:graph:]\fR
 Символи, що виводяться на екран і їх "видно". (Пробіл виводиться, але "не видно", у той час, як \fBa\fR \- і те й інше.)

.TP
.B \fB[:lower:]\fR
 Алфавітні символи нижнього регістру.

.TP
.B \fB[:print:]\fR
 Символ, що можна вивести на екран (не керуючий символ).

.TP
.B \fB[:punct:]\fR
 Розділові знаки (не літери, не цифри, не керуючі символи і не пробіли).

.TP
.B \fB[:space:]\fR
 Символи пробілу (пробіл, табуляція, знак заміни сторінки, (нового рядка)).

.TP
.B \fB[:upper:]\fR
 Алфавітні символи верхнього регістру.

.TP
.B \fB[:xdigit:]\fR
 Символи, що є шістнадцятковими цифрами.

Так, наприклад, до появи стандарту POSIX, для збігу текстових символів потрібно було вказати \fB/[A\-Za\-z0\-9]/\fR. Якщо набір символів (кодування) містив у собі інші символи, то збігу не відбувалося. З класами символів POSIX ви можете написати \fB/[[:alnum:]]/\fR і це збіжиться автоматично зі всіма алфавітними і цифровими символами вашого набору символів.

У списках символів можуть бути вказані ще дві спеціальні послідовності знаків. Вони вживаються з не\-ASCII наборами символів. Одна з них може вказувати на один знак (так називаємий \fIелемент\fR \fIсортування\fR) за допомогою двох знаків і друга послідовність \- це \fIеквівалентні\fR, з погляду сортування, символи. (Наприклад, у Франції, звичайна "e" і акцентована e` еквівалентні.)

.TP
.B \fBСимволи\fR \fBсортування\fR
 \fIСимволи\fR \fIсортування\fR \- це багатосимвольні позначення, включені у \fB[.\fR й \fB.]\fR. Наприклад, якщо \fBch\fR \- це символи сортування, то \fB[[.ch.]]\fR \- це регулярний вираз, що збігається з відповідним \fIелементом\fR \fIсортування\fR (у певній локалі і наборі символів), тоді як звичний \fB[ch]\fR \- це регулярний вираз, що збігається або з \fBc\fR, або \fBh\fR.

.TP
.B \fBКласи\fR \fBеквівалентності\fR
 \fIКлас\fR \fIеквівалентності\fR \- це залежне від локалі ім'я використаним для представлення "e", "Є", і "e`". У цьому випадку, \fB[[=e=]]\fR \- це регулярний вираз, що збігається з \fBe\fR, \fBЄ\fR і \fBe`\fR.

Ці можливості дуже важливі в не\-англійських локалях. Бібліотечні функції, використовувані \fBgawk\fR для роботи з регулярними виразами, у даний момент розпізнають тільки класи символів POSIX. Вони не розпізнають символи сортування і класи еквівалентності.

Оператори \fB\ey\fR, \fB\eB\fR, \fB\e<\fR, \fB\e>\fR, \fB\ew\fR, \fB\eW\fR, \fB\e`\fR й \fB\e\fR', притаманні \fBgawk\fR, являються розширеннями, основаними на можливостях бібліотек регулярних виразів GNU.

Різноманітні опції командного рядка також визначають, як \fBgawk\fR інтерпретує символи, що складають регулярні вирази.

.TP
.B без опцій
 Типово, \fBgawk\fR надає всі можливості регулярних виразів POSIX і розширень GNU, як описано вище. Не підтримуються лише інтервальні вирази.

.TP
.B \fB\-\-posix\fR
 Підтримуються лише регулярні вирази POSIX, оператори GNU не мають спеціального значення.
(Наприклад, \fB\ew\fR відповідає буквальній літері \fBw\fR). Інтервальні вирази дозволено.

.TP
.B \fB\-\-traditional\fR
 Використовуються традиційні регулярні виразу Unix \fBawk\fR. Оператори GNU не мають спеціального значення, інтервальні вирази не підтримуються, так само класи символів POSIX (\fB[[:alnum:]]\fR і т.д. ) не підтримуються. Символи, вказані за допомогою вісімкової або шістнадцяткової екранованої послідовності, сприймаються буквально, навіть якщо вони являють собою метасимволи регулярних виразів.

.TP
.B \fB\-\-re\-interval\fR
 Дозволяє використовувати інтервальні вирази, навіть якщо вказано опцію \fB\-\-traditional\fR.

.SS "Дії"
.PP
Твердження дії включаються у фігурні дужки \fB{\fR й \fB}\fR. Твердження дії можуть складатися з звичайних виразів присвоювання, умовних виразів і циклів, які ви зустрінете в багатьох інших мовах. Оператори, контрольні структури і вирази вводу/виводу схожі на подібні їм з мови C. 

.SS "Оператори"
.PP
У AWK визначено наступні оператори, у порядку зменшення пріоритету:

.TP
.B \fB$\fR
 Посилання на поле.

.TP
.B \fB++\fR \fB\-\-\fR
 Інкремент і декремент, обидва можуть бути префіксними і постфіксними.

.TP
.B \fB^\fR
 Зведення в ступінь (можна також використовувати \fB**\fR і \fB**=\fR з оператором присвоювання).

.TP
.B \fB+\fR \fB\-\fR \fB!\fR
 Унарний плюс, унарний мінус і логічне заперечення.

.TP
.B \fB*\fR \fB/\fR \fB%\fR
 Множення, ділення і рештка.

.TP
.B \fB+\fR \fB\-\fR
 Додавання і віднімання.

.TP
.B \fIпробіл\fR
 Зчеплення рядків.

.TP
.B \fB<\fR \fB>\fR
.br
\fB<=\fR \fB>=\fR
.br
\fB!=\fR \fB==\fR
 Звичайні операції порівнювання.

.TP
.B \fB~\fR \fB!~\fR
 Збіг і заперечення збігу з регулярним виразом. \fBПримітка:\fR не використовуйте сталий регулярний вираз (\fB/foo/\fR) ліворуч від \fB~\fR або \fB!~\fR, тільки праворуч. Вираз \fB/foo/\fR\fI~\fR \fBexpr\fR має те саме значення, що й \fB(($0\fR \fB~\fR \fB/foo/)\fR \fB~\fR \fIexpr\fR\fB)\fR. Звичайно, це не те, що малося на увазі.

.TP
.B \fBin\fR
 Існування в масиві.

.TP
.B \fB&&\fR
 Логічне І.

.TP
.B \fB||\fR
 Логічне АБО .

.TP
.B \fB?:\fR
 Умовний вираз C. Він має вигляд \fIвираз1\fR \fB?\fR \fIвираз2\fR \fB:\fR \fIвираз3\fR. Якщо \fIвираз1\fR є істиною, то результатом буде значення \fIвиразу2\fR, у протилежному випадку \- \fIвиразу3\fR. Обчислюється лише один з \fIвиразу2\fR або \fIвиразу3\fR.

.TP
.B \fB=\fR \fB+=\fR \fB\-=\fR
.br
\fB*=\fR \fB/=\fR \fB%=\fR \fB^=\fR
 Присвоювання. Підтримується як просте присвоєння (\fIзмінна\fR\fB=\fR\fIзначення\fR), так і присвоювання за допомогою складених операторів.

.SS "Керування потоком"
.PP
Операторами керування потоком є:

.RS
.nf
 \fBif\fR \fB(\fR\fIумова\fR\fB)\fR \fIтвердження\fR [ \fBelse\fR \fIтвердження\fR ]
 \fBwhile\fR \fB(\fR\fIумова\fR\fB)\fR \fIтвердження\fR
 \fBdo\fR \fIтвердження\fR \fBwhile\fR \fB(\fR\fIумова\fR\fB)\fR
 \fBfor\fR \fB(\fR\fIвираз1\fR\fB;\fR \fIвираз2\fR\fB;\fR \fIвираз3\fR\fB)\fR \fIтвердження\fR
 \fBcontinue\fR
 \fBdelete\fR \fIмасив\fR\fB[\fR\fIіндекс\fR\fB]\fR
 \fBdelete\fR \fIмасив\fR
 \fBexit\fR \fB[\fR \fIвираз\fR \fB]\fR
 \fB{\fR \fIтвердження\fR \fB}\fR

.fi
.RE

.SS "Виразиi вводу/виводу"
.PP
Твердженнями вводу/виводу є наступні:

.TP
.B \fBclose(\fR\fIфайл\fR [\fB,\fR \fIяк\fR]\fB)\fR
 Закрити файл, канал або співпроцес. Опція \fIяк\fR повинна вживатися лише у випадку закриття одного кінця двостороннього каналу або процесу. Це повинно бути ланцюжком \fB"to"\fR або \fB"from"\fR.

.TP
.B \fBgetline\fR
 Надасть \fB$0\fR значення наступного прочитаного відрізку. Встановить \fBNF\fR, \fBNR\fR, \fBFNR\fR.

.TP
.B \fBgetline\fR \fB<\fR\fIфайл\fR
 Надасть \fB$0\fR значення наступного відрізку \fIфайлу\fR. Встановить \fBNF\fR.

.TP
.B \fBgetline\fR \fIзмінна\fR
 Надасть \fIзмінній\fR значення наступного відрізку. Встановить \fBNR\fR, \fBFNR\fR.

.TP
.B \fBgetline\fR \fIзмінна\fR \fB<\fR\fIфайл\fR
 Надасть \fIзмінній\fR значення наступного відрізку з \fIфайлу\fR.

.TP
.B \fIкоманда\fR \fB|\fR \fBgetline\fR [\fIзмінна\fR]
 Виконати \fIкоманду\fR, передаючи її вивід або \fB$0\fR, або \fIзмінній\fR.

.TP
.B \fIкоманда\fR \fB|&\fR \fBgetline\fR [\fIзмінна\fR]
 Виконати \fIкоманду\fR як співпроцес, передаючи її вивід \fB$0\fR або \fIзмінній\fR. Співпроцеси є розширенням \fBgawk\fR.

.TP
.B \fBnext\fR
 Припинити обробку поточного вхідного відрізку. Прочитати наступний вхідний відрізок і почати його обробку з самого початку, з першого шаблону програми AWK. Якщо досягнуто кінця вхідних даних, блок(и) \fBEND\fR буде виконано, якщо є такі.

.TP
.B \fBnextfile\fR
 Припинити обробку поточного вхідного файлу. Наступний вхідний відрізок буде прочитано з наступного вхідного файлу. \fBFILENAME\fR і \fBARGIND\fR оновлюються, \fBFNR\fR перезаладоване до 1 і обробка починається з першого шаблону програми AWK. Якщо досягнуто кінця вхідних даних, то буде виконано закінчується вмістом змінної \fBORS.\fR

.TP
.B \fBprint\fR \fIспискок\-виразів\fR
 Вивести вирази. Вирази розділено вмістом змінної \fBOFS\fR. Вивід відрізку закінчується вмістом змінної \fBORS\fR.

.TP
.B \fBprint\fR \fIспискок\-виразів\fR \fB>\fR\fIфайл\fR
 Вивести вирази до файлу. Вирази розділено вмістом змінної \fBOFS\fR. Вивід відрізку закінчується вмістом змінної \fBORS\fR.

.TP
.B \fBprintf\fR \fIформат\fR\fB,\fR \fIспискок\-виразів\fR
 Форматувати і вивести.

.TP
.B \fBprintf\fR \fIформат\fR\fB,\fR \fIспискок\-виразів\fR \fB>\fR\fIфайл\fR
 Форматувати і вивести до файлу.

.TP
.B \fBsystem(\fR\fIкоманда\fR\fB)\fR
 Виконати оболонкову \fIкоманду\fR, і повернути код її виходу. (Може не працювати на не\-POSIX системах.)

.TP
.B \fBfflush(\fR[\fIфайл\fR]\fB)\fR
 Звільнити буфери, зв'язані з відкритим для виводу файлом або каналом \fIфайл\fR. Якщо \fIфайл\fR не вказано, відбувається звільнення буферу стандартного виводу. Якщо \fIфайл\fR вказано як порожній ланцюжок, то відбувається скидання буферів усіх відкритих для виводу файлів і каналів.

Дозволені також додаткові перенаправлення вводу\-виводу для \fBprint\fR і \fBprintf\fR:

.TP
.B \fBprint\fR \fB...\fR \fB>>\fR \fIфайл\fR
 Додасть виведені дані до \fIфайлу\fR.

.TP
.B \fBprint\fR \fB...\fR \fB|\fR \fIкоманда\fR
 Передасть дані каналу.

.TP
.B \fBprint\fR \fB...\fR \fB|&\fR \fIкоманда\fR
 Передасть дані співпроцесу.

Команда \fBgetline\fR повертає 0 по досягненні кінця файлу і \-1 при помилці. У випадку помилки, \fBERRNO\fR міститиме рядок з описом помилки.

\fBЗауваження:\fR при використанні каналу або співпроцесу з \fBgetґ\fR \fBline\fR або \fBprint\fR чи \fBprintf\fR всередині циклу, ви повинні використати \fBclose()\fR для створення нових випадків команди. AWK не закриває автоматично канали або співпроцеси після повернення ними EOF (знак кінця файлу).

AWK printf і функція sprintf() (дивіться нижче) розпізнають наступні формати перетворень:

.TP
.B \fB%c\fR
 ASCII\-символ. Якщо аргумент \fB%c\fR є числом, то його буде інтерпретовано як символ і виведено. У протилежному випадку, аргумент буде інтерпретовано як ланцюжок, і виводиться тільки перший символ цього ланцюжка.

.TP
.B \fB%d\fR
.br
\fB%і\fR
 Десяткове число (ціла частина).

.TP
.B \fB%e\fR
.br
\fB%E\fR
 Число з плаваючою точкою у формі \fB[\-]d.dddddde[+\-]dd\fR. Формат \fB%E\fR використовує \fBE\fR
замість \fBe\fR.

.TP
.B \fB%f\fR
 Число з плаваючою точкою у формі \fB[\-]ddd.dddddd\fR.

.TP
.B \fB%g\fR
.br
\fB%G\fR
 Використовувати формат \fB%e\fR або формат \fB%f\fR, у залежності від того, чий вивід коротший, з придушеними незначущими нулями. Формат \fB%G\fR використовує \fB%E\fR замість \fB%e\fR.

.TP
.B \fB%o\fR
 Беззнакове вісімкове число (ціле).

.TP
.B \fB%u\fR
 Беззнакове десяткове число (також ціле).

.TP
.B \fB%s\fR
 Ланцюжок символів.

.TP
.B \fB%x\fR
.br
\fB%X\fR
 Беззнакове шістнадцяткове число (ціле). Формат \fB%X\fR використовує \fBABCDEF\fR замість \fBabcdef\fR.

.TP
.B \fB%%\fR
 Єдиний символ \fB%\fR. Перетворення аргументу не відбувається.

\fBЗауваження:\fR під час використання вказівників формату цілих чисел із значеннями, що перевищують обсяг цілого \fBlong\fR у C, \fBgawk\fR автоматично переключається до вказівника \fB%g\fR. Якщо вказана опція \fB\-\-lint\fR на командному рядку, \fBgawk\fR попередить вас про це. Інші версії \fBawk\fR можуть вивести недійсні числа або поводитись невизначено.

Можна також вказати додаткові параметри між символом \fB%\fR і літерою формату:

.TP
.B \fIn\fR\fB$\fR
 Використати \fIn\fR\-ний аргумент форматування у цьому місці. Це називається \fIвказівником\fR \fIпозиції\fR і застосовується насамперед у перекладених версіях форматувальних ланцюжків, а не у оригінальних  

.TP
.B \fB\-\fR
 Вираз вирівнюється вліво у своєму полі.

.TP
.B \fIпробіл\fR
 Для числових перетворень, виводити перед додатковими значеннями пробіл, а перед від'ємними \- знак мінуса.

.TP
.B \fB+\fR
 Знак плюс перед параметром ширини (дивіться нижче), вказує завжди виводити знак для числових
перетворень, навіть якщо форматовані дані мають додаткове значення. \fB+\fR пересилює вказівника простору.

.TP
.B \fB#\fR
 Використовувати "альтернативну форму" для деяких літер форматів. Для \fB%o\fR \- вивести спереду нуль. Для
\fB%x\fR і \fB%X\fR \- вивести спереду \fB0x\fR або \fB0X\fR, якщо результат відмінний від нуля. Для \fB%e\fR, \fB%E\fR і \fB%f\fR \- результат завжди буде містити десяткову точку. Для \fB%g\fR і \fB%G\fR \- кінцеві нулі не будуть прибрані.

.TP
.B \fB0\fR
 Передуючий \fB0\fR (нуль) служить вказівником того, що виведене поле повинне бути заповненим нулями, а не пробілами. Це стосується навіть не\-числових форматів виводу. Цей вказівник має зміст лише тоді, коли ширина поля є більшою за виведене значення.

.TP
.B \fIширина\fR
 Поле повинно бути заповненим до цієї ширини. Звичайно, поле заповнюється пробілами . Якщо вказано \fB0\fR, то поле заповниться нулями.

.TP
.B .\fIточність\fR
 Число, що визначає точність виводу. Для форматів \fB%e\fR, \fB%E\fR і \fB%f\fR вказує кількість цифр, виведених праворуч від десяткової точки. Для форматів \fB%g\fR і \fB%G\fR вказує максимальну кількість значущих цифр. Для форматів \fB%d\fR \fB,\fR \fB%o\fR, \fB%і\fR, \fB%u\fR, \fB%x\fR і \fB%X\fR вказує мінімальну кількість виведених цифр. Для \fB%s\fR вказує максимальну кількість виведених символів ланцюжка.

Підтримуються динамічні ширина і точність функції \fBprintf()\fR ANSI C. Якщо замість ширини або точності вказати \fB*\fR, то їхні значення будуть взяті зі списку аргументів \fBprintf\fR або \fBsprintf()\fR.

.SS "Спеціальні назви файлів"
.PP
При перенаправленні вводу\-виводу \fBprint\fR і \fBprintf\fR до файлу або \fBgetline\fR з файлу, \fBgawk\fR розпізнає деякі спеціальні назви файлів. Ці назви можуть використовуватись для доступу до дескрипторів відкритих файлів, успадкованих від батьківського процесу \fBgawk\fR (звичайно оболонки). Ці назви файлів можуть також використовуватись на командному рядку для вказівки фалів, що містять дані. Ось їхній перелік:

.TP
.B \fB/dev/stdin\fR
 Стандартний ввід.

.TP
.B \fB/dev/stdout\fR
 Стандартний вивід.

.TP
.B \fB/dev/stderr\fR
 Вивід стандартної помилки.

.TP
.B \fB/dev/fd/\fR\fIn\fR
 Файл, що відповідає відкритому дескриптору файлу \fIn\fR.

Останні особливо корисні для виводу помилок. Наприклад:

.RS
\fBprint\fR \fBYou\fR \fBblew\fR \fBit!\fR \fB>\fR \fB/dev/stderr\fR
.RE

тоді як звичайно вам довелося ви використати

.RS
\fBprint\fR \fBYou\fR \fBblew\fR \fBit!\fR \fB|\fR \fBcat\fR \fB1>&2\fR
.RE

Наступні спеціальні назви файлів можуть використовуватись з оператором співпроцесу \fB|&\fR для створення мережних
з'єднань TCP/IP:

.TP
.B \fB/inet/tcp/\fR\fIlport\fR\fB/\fR\fIrhost\fR\fB/\fR\fIrport\fR
 Файл для TCP/IP з'єднання на локальному порту \fIlport\fR із віддаленим хостом \fIrhost\fR на віддаленому порту \fIrport\fR. Використайте порт \fB0,\fR щоб система сама вибрала необхідний порт.

.TP
.B \fB/inet/udp/\fR\fIlport\fR\fB/\fR\fIrhost\fR\fB/\fR\fIrport\fR
 Схожий до попереднього, але для UDP/IP з'єднання.

.TP
.B \fB/inet/raw/\fR\fIlport\fR\fB/\fR\fIrhost\fR\fB/\fR\fIrport\fR
 Зарезервований для майбутнього вжитку.

Ще інші, надають доступ до інформації про запущені процеси \fBgawk\fR. \fIЦі\fR \fIназви\fR \fIфайлів\fR \fIзастаріли\fR \fI.\fR Використовуйте натомість масив (змінної середовища) \fBPROCINFO\fR для отримання відповідної інформації. Ось ці назви:

.TP
.B \fB/dev/pid\fR
 Читання цього файлу повертає ID поточного процесу у вигляді десяткового числа з символом нового рядка
наприкінці.

.TP
.B \fB/dev/ppid\fR
 Читання цього файлу повертає ID батьківського процесу у вигляді десяткового числа з символом нового рядка наприкінці.

.TP
.B \fB/dev/pgrpid\fR
 Читання цього файлу повертає ID групи поточного процесу у  вигляді  десяткового  числа  з  символомнового рядка наприкінці.

.TP
.B \fB/dev/user\fR
 Читання цього файлу повертає один відрізок, що закінчується символом нового рядка. Поля розділено пробілами. \fB$1\fR отримає значенням системного виклику \fBgetuid\fR(2), \fB$2\fR \- значення системного виклику \fBgeteuid\fR(2), \fB$3\fR \- значення системного виклику \fBgetgid\fR(2) і \fB$4\fR \- значення системного виклику \fBgetegid\fR(2). Якщо є додаткові поля, то вони отримають значення ID груп, повернутими \fBgetgroups\fR(2). Багаточисельні групи можуть не підтримуватись всіма системами.

.SS "Математичні функції"
.PP
AWK має наступні вбудовані математичні функції:

.TP
.B \fBatan2(\fR\fIy\fR\fB,\fR \fIx\fR\fB)\fR
 повертає арктангенс \fIy/x\fR у радіанах.

.TP
.B \fBcos(\fR\fIвираз\fR\fB)\fR
 повертає косинус \fIвиразу\fR, вираз повинен бути в радіанах.

.TP
.B \fBexp(\fR\fIвираз\fR\fB)\fR
 експонентна функція.

.TP
.B \fBint(\fR\fIвираз\fR\fB)\fR
 відкидає дробову частину.

.TP
.B \fBlog(\fR\fIвираз\fR\fB)\fR
 функція натурального логарифма.

.TP
.B \fBrand()\fR
 повертає випадкове число \fIN\fR між 0 і 1, тобто 0 < \fIN\fR < 1.

.TP
.B \fBsin(\fR\fIвираз\fR\fB)\fR
 повертає синус \fIвиразу\fR. Вираз повинен бути в радіанах.

.TP
.B \fBsqrt(\fR\fIвираз\fR\fB)\fR
 функція квадратного кореня.

.TP
.B \fBsrand(\fR[\fIвираз\fR]\fB)\fR
 встановлює \fIвираз\fR як нове зерно для генератора випадкових чисел. Якщо вираз не вказано, то використовується поточний час. Значення, що повертається, дорівнює попередньому зерну генератора випадкових чисел.

.SS "Ланцюжкові функції"
.PP
\fBGawk\fR має наступні вбудовані ланцюжкові функції:

.TP
.B \fBasort(\fR\fIs\fR [\fB,\fR \fId\fR]\fB)\fR
 Повертає кількість елементів вихідного масиву \fIs\fR. Елементи \fIs\fR сортовані, використовуючи звичайні правила \fBgawk\fR порівнювання значень. Індекси відсортованих значень заміняються послідовністю цілих чисел, починаючи з 1. Якщо буде вказаний додатковий масив залишаючи індекси джерельного масиву \fIs\fR незмінними.

.TP
.B \fBasorti(\fR\fIs\fR [\fB,\fR \fId\fR]\fB)\fR
 Повертає кількість елементів вихідного масиву \fIs\fR. Поведінка нагадує ту, яку ми спостерігаємо в \fBasort()\fR, за винятком того, що \fIіндекси\fR масиву використовуються для сортування, а не значення елементів масиву. Після закінчення, масив буде індексовано десятковими числами, кожний елемент зі значенням попереднього індексу. Старі значення масиву відкидаються, тож додайте другий масив, якщо хочете зберегти оригінальний.

.TP
.B \fBgensub(\fR\fIr\fR\fB,\fR \fIs\fR\fB,\fR \fIh\fR [\fB,\fR \fIt\fR]\fB)\fR
 Шукає в рядку \fIt\fR збіги з регулярним виразом \fIr\fR. Якщо \fIh\fR є ланцюжком, що починається з \fBg\fR або \fBG\fR, то замінює всі збіги \fIr\fR на \fIs\fR. У протилежному випадку, \fIh\fR буде числом, що вказуватиме, який по рахунку збіг \fIr\fR замінити. Якщо \fIt\fR не вказано , то використовується \fB$0\fR. У тексті заміни \fIs\fR, послідовність \fB\e\fR\fIn\fR, де \fIn\fR \- це цифра від 1 до 9, може бути використаною для посилання на текст \fIn\fR\-нної, включеної в дужки, частини виразу. Послідовність \fB\e0\fR посилається на весь текст, що збігся, так само символ \fB&\fR. На відміну від \fBsub()\fR і \fBgsub()\fR, змінений ланцюжок буде повернуто як результат функції, а оригінальний вихідний ланцюжок \fIзалишається\fR \fIнезмінним\fR.

.TP
.B \fBgsub(\fR\fIr\fR\fB,\fR \fIs\fR [\fB,\fR \fIt\fR]\fB)\fR
 Кожна частина ланцюжка \fIt\fR, що збіглася з регулярним виразом \fIr\fR, замінюється на ланцюжок \fIs\fR і повертається кількість здійснених замін. Якщо \fIt\fR не вказаний, то використовується \fB$0\fR. Місце \fB&\fR у тексті заміни \fIs\fR візьме ланцюжок, що збігся. Для виводу буквального символу \fB&\fR використовуйте \fB\e&\fR (це повинно виглядати як \fB"\e\e&"\fR). (Для подальшої дискусії стосовно \fB&\fR і \fB\e\fR у тексті заміни у \fBsub()\fR, \fBgsub()\fR і \fBgensub()\fR, зверніться до "GAWK: Effective AWK Programming".)

.TP
.B \fBindex(\fR\fIs\fR\fB,\fR \fIt\fR\fB)\fR
 Повертає індекс ланцюжка \fIt\fR у ланцюжку \fIs\fR, або 0, якщо \fIt\fR не знайдено. (Це також означає, що відлік індексів знаків починається з 1.)

.TP
.B \fBmatch(\fR\fIs\fR\fB,\fR \fIr\fR [\fB,\fR \fIa\fR]\fB)\fR
 Повертає позицію в \fIs\fR, де відбулося співпадання з регулярним виразом \fIr\fR, або 0, якщо співпадання з \fIr\fR не відбулося. Встановлює значення \fBRSTART\fR і \fBRLENGTH\fR. Зауважте, що послідовність аргументів є тією самою, що й для оператора \fB~\fR, тобто \fIланцюжок\fR \fB~\fR \fIregex\fR. Якщо додатково вказати масив \fIa\fR, його буде очищено, після чого елементи з 1 по \fIn\fR заповнено частинами \fIs\fR, що співпадають з відповідними, взятими в дужки, частинами виразу \fIr\fR. Елемент з індексом 0 в \fIa\fR утримуватиме ту частину \fIs\fR,що співпала з цілим регулярним виразом \fIr\fR. Елементи, індексовані як \fBa[\fR\fIn\fR\fB,\fR \fB"start"]\fR і \fBa[\fR\fIn\fR\fB,\fR \fB"length"]\fR надають інформацію про перший індекс у ланцюжку і довжину кожної частини ланцюжка, що співпала.

.TP
.B \fBsplit(\fR\fIs\fR\fB,\fR \fIa\fR [\fB,\fR \fIr\fR]\fB)\fR
 Розбиває рядок \fIs\fR, керуючись регулярним виразом \fIr,\fR зберігає результат у масив \fIa\fR і повертає кількість полів. Якщо \fIr\fR не вказано, то використовується \fBFS\fR. Масив \fIa\fR попередньо очищається. Функція працює подібно до поділу на поля, описаного вище. 

.TP
.B \fBsprintf(\fR\fIfmt\fR\fB,\fR \fIexpr\-list\fR\fB)\fR
 Виводить список виразів відповідно до формату \fIfmt\fR.

.TP
.B \fBsub(\fR\fIr\fR\fB,\fR \fIs\fR [\fB,\fR \fIt\fR]\fB)\fR
 Схожа до \fBgsub()\fR, але замінюється тільки перша частина ланцюжка, що співпала з \fIr\fR.

.TP
.B \fBsubstr(\fR\fIs\fR, \fIі\fR \fI[\fR\fB,\fR \fIn]\fR\fB)\fR
 Повертає \fIn\fR\-символьну частину ланцюжка \fIs\fR, починаючи з \fIі\fR. Якщо \fIn\fR не вказати, то повертається залишок рядка \fIs\fR.

.TP
.B \fBtolower(\fR\fIланцюжок\fR\fB)\fR
 Повертає копію \fIланцюжка\fR, у якій всі символи верхнього регістру, переведені у
відповідні їм символи нижнього регістру. Не\-алфавітні символи залишаються без змін.

.TP
.B \fBtoupper(\fR\fIланцюжок\fR\fB)\fR
 Повертає копію \fIланцюжка\fR, у якій усі символи нижнього регістру, переведені у відповідні їм символи верхнього регістру. Не\-алфавітні символи залишаються без змін.

.SS "Функції роботи з часом"
.PP
Оскільки одним з основних застосувань програм AWK являється обробка журнальних файлів, що містять мітки часу, \fBgawk\fR надає декілька функцій для отримання і форматування міток часу .

.TP
.B \fBmktime(\fR\fIформат\fR\fB)\fR
 Перетворює формат у мітку часу схоже до \fBsystime()\fR, наведеної нижче. Формат є ланцюжком у формі YYYY MM DD HH MM SS [DST]. Вміст ланцюжка повинен складатись з шести або семи чисел, що відповідатимуть, відповідно: повному запису року, місяцю від 1 до 12, даті від 1 до 31, годині від 0 до 23, хвилині від 0 до 59, секунді від 0 до 60 і, необов'язковій, вказівці літнього часу. Значення цих чисел не обов'язково повинні бути в межах, вказаних вище, наприклад, година \-1 означатиме одну годину до півночі. Час обчислюється за нуль\-основаним Григоріанським календарем. Припускається, що це час місцевого часового поясу. Якщо прапорець літнього часу додатковий, вважатиметься, що це літній час, у протилежному випадку, що це стандартний час. У випадку від'ємного значення, \fBmktime()\fR намагається сама визначити чи вказаний час є літнім, чи ні. Якщо формат містить недостатньо елементів, або якщо обчислений час не є дійсним, \fBmktime()\fR повертає \-1.

.TP
.B \fBstrftime(\fR[\fIформат\fR [\fB,\fR \fIчас\fR]]\fB)\fR
 Форматує час відповідно до вказаного \fIформату\fR. Час повинен бути у тій самій формі, що повертається \fBsystime()\fR. Якщо \fIчас\fR не вказано, то використовується поточний час. Якщо не вказано \fIформат\fR, то використовується формат за замовчуванням, еквівалентний виводові \fBdate(1)\fR. Для гарантії правильності використовуваних форматів, зверніться до специфікації функції \fBstrftime()\fR ANSI C. Вільно розповсюджувана версія \fBstrftime\fR(3) і відповідна сторінка посібника до неї поставляються з \fBgawk\fR. Якщо ця версія використовувалась для збірки \fBgawk\fR, то всі формати, описані в посібнику, будуть доступні програмі \fBgawk.\fR

.TP
.B \fBsystime()\fR
 Повертає поточний час у вигляді кількості секунд із початку Epoch (північ UTC, 1 січня 1970 року, на
системах POSIX).

.SS "Функції побітових операцій"
.PP
Починаючи з версії 3.1 \fBgawk\fR, з'явилися додаткові функції по обробці бітів. Їхня дія полягає у перетворенні чисел з плаваючої точкою подвійної точності у беззнакові довгі (\fBunsigned\fR \fBlong\fR) цілі, здійснення операцій, після чого  \fBand(\fR\fIv1\fR\fB,\fR \fIv2\fR\fB)\fR Повертає порозрядне І значень \fIv1\fR і \fIv2\fR.

.TP
.B \fBcompl(\fR\fIval\fR\fB)\fR
 Повертає порозрядне доповнення значення \fIval\fR.

.TP
.B \fBlshift(\fR\fIval\fR\fB,\fR \fIcount\fR\fB)\fR
 Повертає значення \fIval\fR, зсунутого вліво на \fIcount\fR бітів.

.TP
.B \fBor(\fR\fIv1\fR\fB,\fR \fIv2\fR\fB)\fR
 Повертає порозрядне АБО значень \fIv1\fR і
\fIv2\fR.

\fBrshift(\fR\fIval\fR\fB,\fR \fIcount\fR\fB)\fR Повертає значення \fIval\fR, зсунутого
вправо на \fIcount\fR бітів.

.TP
.B \fBxor(\fR\fIv1\fR\fB,\fR \fIv2\fR\fB)\fR
 Повертає порозрядне XOR значень \fIv1\fR і \fIv2\fR.

.SS "Функції інтернаціоналізації"
.PP
Починаючи з \fBgawk\fR 3.1, можна використовувати наступні функції для перекладу ланцюжків під час обігу програми. Для повного опису дивіться "GAWK: Effective AWK Programming".

.TP
.B \fBbindtextdomain(\fR\fIdirectory\fR [\fB,\fR \fIdomain\fR]\fB)\fR
 Вказує каталог \fIdirectory\fR, де \fBgawk\fR шукатиме файли з закінченням \fB.mo\fR, у випадку, якщо вони не були або не можуть бути розміщеними у "стандартні" місцезнаходження. Вона повертає теку, до якої "прив'язано" домен \fIdomain\fR. Домен з узгодженням вказується у змінній \fBTEXTDOMAIN\fR \fB.\fR Якщо теку вказано як порожній рядок (\fB""\fR), тоді \fBbindtextdomain()\fR повертає поточну "прив'язку" для даного домену.

.TP
.B \fBdcgettext(\fR\fIs\fR [\fB,\fR \fIdomain\fR [\fB,\fR \fIcategory\fR]]\fB)\fR
 Повертає переклад ланцюжка \fIs\fR у текстовому домені \fIdomain\fR і категорії локалі \fIcategory\fR. Стандартним значенням для домену буде значення змінної \fBTEXTDOMAIN\fR. Стандартним значенням категорії \- \fB"LC_MESAGES"\fR. Якщо ви хочете поміняти категорію, впевніться що вона відповідає одній з дійсних категорій локалі, описаних у "GAWK: Effective AWK Programming". Ви також повинні вказати текстовий домен. Використайте \fBTEXTDOMAIN\fR для вживання поточного домену.

.TP
.B \fBdcngettext(\fR\fIs1\fR \fB,\fR \fIs2\fR \fB,\fR \fIn\fR [\fB,\fR \fIdomain\fR [\fB,\fR \fIcategory\fR]]\fB)\fR
 Повертає форму множини ланцюжків \fIs1\fR і \fIs2\fR, що відповідає числу \fIn\fR, згідно з текстовим доменом \fIdomain\fR і категорією локалі \fIcategory\fR. Стандартним значенням для домену буде значення змінної \fBTEXTDOMAIN\fR для вживання поточного домену.

.SH "ФУНКЦІЇ КОРИСТУВАЧА"
.PP
Функції в AWK визначаються у наступний спосіб:

.RS
\fBfunction\fR \fIім'я\fR\fB(\fR\fIсписок\fR \fIпараметрів\fR\fB)\fR \fB{\fR \fIтвердження\fR \fB}\fR
.RE

Функції виконуються при виклику їх з виразів шаблонів або дій. Параметри, вказані при виклику функції використовуються для надання значень формальним параметрам оголошеним у функції. Масиви завжди передаються через посилання на них, інші змінні \- через їхнє значенням. 

Оскільки функції не завжди були частиною мови AWK, підтримка локальних змінних залишає бажати кращого: вони вказуються як додаткові параметри в списку параметрів. Загальноприйнятою умовністю є відокремлювати локальні змінні в списку параметрів від дійсних параметрів додатковими пробілами. Наприклад:

.RS
.nf
 \fBfunction\fR \fBf(p,\fR \fBq,\fR \fBa,\fR \fBb)\fR \fB#\fR \fBa\fR \fB&\fR \fBb\fR \fB\-\fR \fBлокальні\fR \fBзмінні\fR
 \fB{\fR
 \fB...\fR
 \fB}\fR

.fi
.RE

.SS "Виклик функції"
.PP

.RS
.nf
 \fB/abc/\fR \fB{\fR \fB...\fR \fB;\fR \fBf(1,\fR \fB2)\fR \fB;\fR \fB...\fR \fB}\fR

.fi
.RE
Ліва дужка у виклику функції обов'язково повинна стояти одразу за ім'ям функції, без пробілів . Цю вимогу введено для запобігання неоднозначності з операцією зчеплення. Це обмеження не стосується, розглянутих вище, вбудованих функцій.

Функції можуть викликати одне одного і самі себе. Параметрам функцій, використовуваним як локальні змінні, присвоюєтьсязначення порожнього рядка і нуля під час виклику функцій (без надання значення параметрам).

Для повернення певного значення з функції використовуйте вираз \fBreturn\fR. Повернене значення буде невизначеним, якщо не вказано вираз або, якщо вихід з функції відбувається після закінчення тіла функції.

Якщо вказано опцію \fB\-\-lint\fR, то \fBgawk\fR попереджатиме про всі виклики невизначених функцій не під час роботи програми, а заздалегідь, під час попередньої обробки. Виклик невизначеної функції під час роботи програми спричинить фатальну помилку.

Замість слова \fBfunction\fR можна використати \fBfunc\fR.

.SH "ДИНАМІЧНІ ВБУДОВАНІ ФУНКЦІЇ"
.PP
Починаючи з версії 3.1 \fBgawk\fR, вам надається можливість додавати нові вбудовані функції запущеному інтерпретатору \fBgawk\fR. Повний опис є поза масштабом цієї сторінки; зверніться до "GAWK: Effective AWK Programming".

.TP
.B \fBextension(\fR\fIobject\fR\fB,\fR \fIfunction\fR\fB)\fR
 Динамічно завантажити спільний об'єкт \fIobject\fR і викликати функцію \fIfunction\fR з цього об'єкту, для ініціалізації. Обидва параметри повинні бути надано як ланцюжки. Повертає значення, повернуте функцією \fIfunction\fR.

Ця функція описана у GAWK: Effective AWK Programming", але все, що стосується цієї можливості, може помінятись у наступному релізі. Ми радимо уникати цієї риси там, де ви не хочете міняти код пізніше.

.SH "СИГНАЛИ"
.PP
\fBpgawk\fR розпізнає наступні два сигнали:

.TP
.B \fBSIGUSR1\fR
 Викличе викид стеку профілю і викликів функцій у файл профілю \fIawkprof.out\fR або той що було вказано зкомандного рядка опцією \fB\-\-profile\fR. Програма після цього продовжить свою роботу.  

.TP
.B \fBSIGHUP\fR
 Викличе викид стеку профілю і викликів функцій і припинить роботу програми.

.SH "ПРИКЛАДИ"
.PP
Вивести і відсортувати назви всіх користувачів:

.RS
.nf
 \fBBEGIN { FS = ":" }\fR
       \fB{ print $1 | "sort" }\fR

.fi
.RE
Підрахувати кількість рядків у файлі:

.RS
.nf
             \fB{ nlines++ }\fR
 \fBEND   { print nlines }\fR

.fi
.RE
Додати номер попереду кожного рядка у файлі:

.RS
.nf
       \fB{ print FNR, $0 }\fR

.fi
.RE
З'єднати і додати нумерацію рядків (те саме):

.RS
.nf
       \fB{ print NR, $0 }\fR

.fi
.RE
Запустити зовнішню команду для окремих рядків даних:

.RS
.nf
 \fBtail \-f access_log | \e\fR
 \fBawk /index.*/ {system("nmap " $1 ">> logs/index.html")}\fR

.fi
.RE

.SH "ІНТЕРНАЦІОНАЛІЗАЦІЯ"
.PP
Ланцюжкові константи \- це послідовність знаків, включених у подвійні лапки. У не\-англійських середовищах є можливість позначити ланцюжки програми AWK як такі що підлягають перекладу. Такі ланцюжки позначаються у програмах AWK передуючим знаком твердого пробілу ("\fB_\fR"). Наприклад:

.RS
.nf
 \fBgawk BEGIN { print hello, world }\fR

.fi
.RE
завжди виведе hello, world. Зате,

.RS
.nf
 \fBgawk BEGIN { print _"hello, world" }\fR

.fi
.RE
може видрукувати "bonjour, monde" у Франції.

Існує декілька кроків, які необхідно зробити для створення
і запуску локалізованої програми AWK.

1. Додайте дію у \fBBEGIN\fR, яка надасть значення змінній \fBTEXTDOMAIN\fR, що буде асоційоване з назвою вашої програми.

.RS
.nf
 \fBBEGIN { TEXTDOMAIN = myprog }\fR

.fi
.RE
Це дозволяє \fBgawk\fR знайти файли \fB.mo\fR, що вживатимуться з цією програмою. Без цієї вказівки, \fBgawk\fR використовує текстовий домен \fBmessages\fR, який ймовірно не міститиме переклади для вашої програми.

2. Помітьте всі ланцюжки, які ви хочете бути перекладеними, передуючим твердим пробілом.

3. Якщо необхідно, використайте функції \fBdcgettext()\fR або \fBbindtextdomain()\fR у програмі, як було описано вище.

4. Виконайте \fBgawk \-\-gen\-po \-f myprog.awk > myprog.po\fR для створення файлу \fB.po\fR для вашої програми.

5. Перекладіть згенерований файл \fB.po\fR, після чого створіть відповідний файл \fB.mo\fR і інсталюйте його. Це в загальних рисах. Повний опис цієї процедури ви знайдете у "GAWK: Effective AWK Programming".

.SH "СУМІСНІСТЬ З POSIX"
.PP
Основна мета \fBgawk\fR \- це сумісність як зі стандартом POSIX, так і з останніми версіями \fBawk\fR для UNIX. Для цього \fBgawk\fR стандарт POSIX.

У книзі сказано, що присвоєнню значень змінним на командному рядку, відбувається перед відкриттям \fBawk\fR файлів, одразу після виконання блоку \fBBEGIN\fR. Однак у ранніх реалізаціях, таке присвоєння значень відбувалося до виконання блоку \fBBEGIN\fR. Ця "можливість" почала застосовуватися в додатках. Після того, як \fBawk\fR було приведено у відповідність із власною документацією, для того щоб задовольнити додатки, залежні від старого поводження, було додано опцію \fB\-v\fR, що дозволяє надання значення змінним до виконання \fBBEGIN\fR. (Із вводом цієї можливості погодилися як розробники від Bell Laboratories, так і GNU.)

Опція \fB\-W\fR для окремих особливостей реалізацій привнесено стандартом POSIX.

При обробці аргументів \fBgawk\fR використовує спеціальну опцію "\fB\-\-\fR" для позначення кінця аргументів. У режимі сумісності, вона викликатиме попередження про існування невідомих опцій, але вони ігноруються. У звичайному режимі, такі аргументи передаються для обробки програмі AWK.

У книжці AWK не описано значення, що повертається \fBsrand()\fR. Стандарт POSIX вказує повертати попереднє значення зерна, що дозволяє стежити за послідовністю випадкових чисел. Тому \fBsrand()\fR у \fBgawk\fR також повертає значення поточного випадкового зерна.

Інші нові можливості: можливість використання декількох опцій \fB\-f\fR (з MKS \fBawk\fR); масив \fBENVIRON\fR; екрануючі послідовності \fB\ea\fR і \fB\ev\fR (спочатку з'явилися в \fBgawk\fR і потім включені у версію від Bell Laboratories); вбудовані функції \fBtolower()\fR і \fBtoupper()\fR (від Bell Laboratories); означення форматування ANSI C \fBprintf\fR (вперше з'явилися у версії від Bell Laboratories).

.SH "ІСТОРИЧНІ РИСИ"
.PP
\fBgawk\fR підтримуються дві риси ранніх версій AWK. Перша \- можливість виклику вбудованої функції \fBlength()\fR не тільки без аргументу, але й без дужок. Тобто, 

.RS
.nf
 \fBa = length # Holy Algol 60, Batman!\fR

.fi
.RE
є тим самим, що й

.RS
.nf
 \fBa = length()\fR
 \fBa = length($0)\fR

.fi
.RE
Цю можливість помічено як застарілу у стандарті POSIX, і \fBgawk\fR з опцією \fB\-\-lint\fR видаватиме попередження про це. \fBbreak\fR поза тілом циклів \fBwhile\fR, \fBfor\fR або \fBdo\fR. Традиційні реалізації AWK сприймали подібне використання цих операторів, як еквівалентне операторові \fBnext\fR. \fBGawk\fR підтримує таке використання, якщо вказано опцію \fB\-\-traditional.\fR

.SH "РОЗШИРЕННЯ GNU"
.PP
\fBGawk\fR має ряд розширень у порівнянні з POSIX \fBawk\fR. Вони описані в цьому розділі . Наведені нижче розширення можна заборонити запуском \fBgawk\fR з опцією \fB\-\-traditional\fR.

Наступні риси відсутні у POSIX \fBawk\fR:

.br
  *  Не здійснюється пошук шляху до файлів, вказаних через опцію \fB\-f\fR. Тому змінна середовища \fBAWKPATH\fR не є спеціальною.
.br
  *  Екрануюча послідовність \fB\ex\fR. (Скасовується \fB\-\-posix\fR.)
.br
  *  Функція \fBfflush()\fR. (Скасовується \fB\-\-posix\fR.)
.br
  *  Можливість продовжувати рядки після \fB?\fR й \fB:\fR. (Скасовується \fB\-\-posix\fR.)
.br
  *  Вісімкові і шістнадцяткові константи у програмах AWK.
.br
  *  Змінні \fBARGIND\fR, \fBBINMODE\fR, \fBERRNO\fR, \fBLINT\fR, \fBRT\fR і \fBTEXTDOMAIN\fR не мають спеціального значення.
.br
  *  Змінна \fBIGNORECASE\fR і її побічні ефекти відсутні.
.br
  *  Змінна \fBFIELDWIDTHS\fR і поділ на поля фіксованої довжини.
.br
  *  Відсутній масив \fBPROCINFO\fR.
.br
  *  Використання \fBRS\fR як регулярного виразу.
.br
  *  Спеціальні назви файлів для перенаправлення вводу/виводу не розпізнаються.
.br
  *  Оператор \fB|&\fR для створення співпроцесу.
.br
  *  Можливість поділу на окремі символи шляхом присвоєння порожнього значення змінній \fBFS\fR або третього аргументу \fBsplit()\fR.
.br
  *  Необов'язковий другий аргумент функції \fBclose()\fR.
.br
  *  Необов'язковий третій аргумент функції \fBmatch()\fR. 
.br
  *  Можливість   використання   вказівників  позиції  з \fBprintf\fR і \fBsprintf()\fR.
.br
  *  Використання \fIdelete\fR масив для усунення змісту цілого масиву.
.br
  *  Використання \fBnextfile\fR для зупинки обробки поточного вхідного файлу.
.br
  *  Функції \fBand()\fR, \fBasort()\fR, \fBasorti()\fR, \fBbindtextdomain()\fR, \fBcompl()\fR, \fBdcgettext()\fR, \fBdcngettext()\fR, \fBgensub()\fR, \fBlshift()\fR, \fBmktime()\fR, \fBor()\fR, \fBrshift()\fR, \fBstrftime()\fR, \fBstrtonum()\fR, \fBsystime()\fR і \fBxor()\fR.
.br
  *  Локалізовані ланцюжки.
.br
  *  Динамічне додання нових вбудованих функцій завдяки \fBextension()\fR.

Книжка з AWK не визначає значень, що повертаються функцією \fBclose()\fR. Функція \fBclose()\fR програми \fBgawk\fR повертає значення з \fBfclose\fR(3) або \fBpclose\fR(3) при закритті файлу або каналу, відповідно. Повернене значення дорівнюватиме \-1, якщо іменований файл, канал або співпроцес не було відкрито
шляхом перенаправлення.

Якщо під час виклику \fBgawk\fR з опцією \fB\-\-traditional\fR, аргумент \fIfs\fR опції \fB\-F\fR має значення \fB"t"\fR, то значенням \fBFS\fR буде символ табуляції. Зауважте, що введення \fBgawk\fR \fB\-F\et\fR ... призведе лишень до екранування символу \fB"t"\fR, а не до передачі \fB"\et"\fR опції \fB\-F\fR. Оскільки це досить специфічний випадок, то він не являється стандартним поводженням. Це також не буде працювати, якщо вказано опцію \fB\-\-posix\fR. Якщо вам дійсно потрібно використовувати символ табуляції як роздільник полів, то найкраще скористатися одинарними лапками: \fBgawk\fR \fB\-F'\et\fR' ...

Якщо \fBgawk\fR конфігуровано з \fI\-\-enable\-switch\fR під час компіляції, тоді він розумітиме додаткові вирази керування потоком:

.RS
.nf
 \fBswitch (\fR\fIвираз\fR\fB) {\fR
 \fBcase\fR \fIзначення\fR\fB|\fR\fIregex\fR \fB:\fR \fIтвердження\fR
 ...
 [\fBdefault:\fR \fIтвердження\fR]
 \fB}\fR

.fi
.RE

.SH "ЗМІННІ СЕРЕДОВИЩА"
.PP
Змінна \fBAWKPATH\fR може бути використаною для вказівки списку каталогів, у яких \fBgawk\fR шукатиме файли, вказані опцією \fB\-f\fR або \fB\-\-file\fR.

Якщо в середовищі існує змінна \fBPOSIXLY_CORRECT\fR, \fBgawk\fR видасть попередження про сумісність з POSIX.

.SH "ДИВІТЬСЯ ТАКОЖ"
.PP
\fBegrep\fR(1), 
\fBgetpid\fR(2),  \fBgetppid\fR(2),  \fBgetuid\fR(2),  \fBgeteuid\fR(2), 
\fBgetgid\fR(2),  \fBgetegid\fR(2),  \fBgetgroups\fR(2)

The AWK Programming Language, Alfred V. Aho, Brian W. Kernighan, Peter J. Weinberger, Addison\-Wesley, 1988. ISBN 0\-201\-07981\-X.

GAWK: Effective AWK Programming, Edition 3.0, видана Free Software Foundation, 2001.

.SH "ВАДИ"
.PP
Опцію \fB\-F\fR не обов'язково вказувати на командному рядку. Вона підтримується лише для сумісності.

Короткі програми, що містять синтаксичні помилки, схильні переповняти стек обробки, що приводить до малозмістовних
повідомлень. Доволі складно діагнозувати такі програми, і зусилля, витрачені на це не варті того.

.SH "АВТОРИ"
.PP
Оригінальна версія UNIX awk була розроблена і реалізована Alfred Aho, Peter Weinberger і Brian Kernighan у Bell Laboratories. Brian Kernighan продовжує підтримувати і покращувати її.

Paul Rubin і Jay Fenlason від Free Software Foundation, написали gawk, сумісний з оригінальною версією awk, що ввійшла до складу Seventh Edition UNIX. John Woods виправив ряд помилок. David Trueman разом з Arnold Robbins зробили gawk сумісним з новою версією UNIX awk. У даний момент підтримка здійснюється Arnold Robbins.

Перший порт для DOS здійснено Conrad Kwok і Scott Garfinkle. Підтримка версії для DOS на даний момент здійснюється Scott Deifik. Pat Rankin переніс програму на VMS, Michal Jaegermann \- на Atari ST. Портування для OS/2 було здійснене Kai Uwe Rommel спільно з Darrel Hankerson. Fred Fish надав підтримку для Amiga, Stephen Davies переніс на Tandem і Martin Brown \- на BeOS.

.SH "ІНФОРМАЦІЯ ПРО ВЕРСІЮ"
.PP
Ця сторінка описує gawk версії 3.1.5.

.SH "ПОВІДОМЛЕННЯ ПРО ВАДИ"
.PP
Якщо ви знайдете помилку в \fBgawk\fR, будь ласка, вишліть електронною поштою повідомлення на bug\-gnu\-utils@gnu.org. Вкажіть, будь ласка, версію вашої операційної системи, версію gawk, компілятор C, що використовувався для збірки, а також тест програми і дані, мінімально розміру, ласка, зробіть дві речі. По\-перше, впевніться, що у вас встановлено останню версія gawk. Багато помилок (звичайно малопомітних) виправляються в кожній новій версії і, можливо, ваша проблема вже була вирішеною. По\-друге, будь ласка, уважно прочитайте цей посібник, а також ті, посилання на які ви знайдете в ньому, щоб бути впевненим, що це дійсно помилка, а не примха мови .

Щоб ви не робили, НЕ посилайте повідомлення про помилку в comp.lang.awk. Хоча розроблювачі gawk час від часу читають цю конференцію, дописи про помилки не є надійним способом повідомлення. Замість цього, скористайтесь вищенаведеними адресами електронної пошти.

Якщо ви використовуєте GNU/Linux або BSD системи, можливо має зміст відправити повідомлення про ваду виробнику вашого дистрибутиву. З цим все гаразд, але впевніться, що ви додали також копію офіційної електронної адреси, оскільки немає гарантії, що ваду передадуть утримувачу gawk.

.SH "ПОДЯКИ"
.PP
Brian Kernighan з Bell Laboratories за надання цінної допомоги під час тестування і налагодження.

.SH "АВТОРСЬКІ ПРАВА"
.PP
Copyright ╘ 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this manual page provided the copyright notice and this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified versions of this manual page under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual page into another language, under the above conditions for modified versions, except that this permission notice may be stated in a translation approved by the Foundation.

\-\-\-\-
Переклад украінською здійснив Віталій Цибуляк <tech@oboz.com.ua>.

