." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "patch" "1" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

." .\" Переклад: Віталій Цибуляк <vi@uatech.atspace.com> 

.SH " НАЗВА "
.PP
patch \- застосує файл diff до оригіналу 

.SH " КОРОТКИЙ ОГЛЯД "
.PP
\fBpatch [\fR \fIопції\fR \fB] [\fR\fIоригінал\fR \fB [\fR \fIлатка\fR \fB]]\fR 

але частіше лишень: 

\fBpatch  \-p\fR \fIномер\fR \fB <\fR \fIлатка\fR 

.SH " ОПИС "
.PP
\fBpatch\fR візьме файл  \fIлатку , \fR що містить список відмінностей, створений програмою  \fBdiff\fR(1) (ми будемо іноді називати цей список як diff), і вжиє ці відмінності  до одного або більше оригінальних файлів, створюючи залатані версії  файлів. Як правило, залатані версії замінюють оригінали. Резервні  копії також можливі; дивіться опції  \fB\-b \fR або  \fB\-\-backup\fR .  Назви файлів, що належить залатати, беруться з файлу\-\fIлатки\fR, але  якщо це всього лиш один файл, його можна вказати на командному рядку як  \fIоригінал\fR . 

Під час запуску,  \fBpatch\fR намагається визначити тип списку diff, хіба ця поведінка переважена  однією з опцій:  \fB\-c \fR ( \fB\-\-context\fR ),  \fB\-e \fR ( \fB\-ed\fR ),  \fB\-n \fR ( \fB\-\-normal\fR )  або  \fB\-u \fR ( \fB\-\-unified\fR ).  Контекстуальні  відмінності (old\-style, new\-style, і unified) і звичні відмінності \fBpatch\fR вжиє без сторонньої допомоги, тоді як відмінності  \fBed\fR будуть передані через конвеєр редактору  \fBed\fR(1). 

\fBpatch\fR намагається пропустити будь\-яке передуюче сміття, застосувати латку і пропустити кінцеве сміття. Таким чином, ви  можете подати  \fBpatch\fR якусь статтю або послання електронної пошти, що містить список diff серед тексту, і латка повинна спрацювати. Якщо цілий diff зсунуто вправо, або якщо зміст diff містить рядки з закінченням CRLF, або герметизовано (інскапульовано) один або  декілька разів, через додання \- до рядків що починаються з \-, як вказано у RFC 934, це також буде враховано. 

У контекстних diff і, в меншій ступені у звичайних diff,  \fBpatch\fR може вгадати, коли номер рядка, вказаний у латці, не є вірним і намагається знайти правильне місце, де можна вжити кожний  кусок латки. При першій спробі, береться номер рядка, вказаний для куска у латці, плюс або мінус зсув, який застосовувався для аплікації попереднього куска. Якщо місце виявиться невдалим,  \fBpatch\fR сканує в обох напрямках, вперед і назад, на предмет рядків, що співпадають з тими, що вказано в куску. Спочатку  \fBpatch\fR шукає місця, де всі рядки контексту співпадають. Якщо такого не  знайдено, і це контекстний diff, максимальний фактор  похибки встановлено до 1 або більше, тоді наступне сканування матиме місце, ігноруючи перший і останній рядок контексту. Якщо це також зазнає невдачі, і максимальний  фактор похибки встановлено до 2 або більше, перші два й останні два рядка контексту буде ігноровано і додаткове сканування матиме місце. (Фактор похибки за узгодженістю дорівнює 2). 

У випадку, якщо  \fBpatch\fR не може знайти місця застосування куска латки, він збереже цей кусок  у файл відкинутих латок, назва якого буде співпадати з назвою  вихідного файлу, плюс суфікс  \fB.rej \fR або  \fB#\fR ,  якщо  \fB.rej \fR створить файл із занадто довгою назвою (якщо навіть  \fB#\fR неможливо додати, тоді ґратка замінить останній знак назви файлу).  (Кусок, що відкинуто, зберігається у формі контекстуального diff,  незалежно від  того яка форма вживалась у файлі латки. Якщо латка містила звичайний diff, багато з контексту анулюється.)  

Номер рядків кусків у файлі відкинутих латок може відрізнятись  від аналогічних з самої латки: вони відображають приблизне  місцезнаходження, яке на думку  \fBpatch\fR не вдалося залатати у новому файлі (вже після дії  \fBpatch\fR )  а не у старому. По мірі того, як кожний кусок оброблено, ви отримаєте  інформацію, котрий з них зазнав невдачі і якому саме рядку (нового файлу),  \fBpatch\fR гадає, належить цей кусок.    

Якщо кусок розміщено в обробленому тексті у відмінному місці від того що вказано у файлі\-латці, ви також отримаєте інформацію про розмір зміщення. Одне велике зміщення може означати, що кусок розміщено у хибному місці. Важ також поінформують про фактор похибки, який використовувався для співпадань. Якщо була вказана опція  \fB\-\-verbose\fR ,  ви додатково отримаєте інформацію про те, які з кусків співпали точно. 

Якщо жодного файлу \fIоригіналу\fR не було вказано на командному рядку,  \fBpatch\fR спробує вгадати з файлу латки, який саме файл редагувати, керуючись  наступними правилами: 

.br
  *  Якщо заголовок вказує що це контекстний diff,  \fBpatch\fR візьме назви старого і нового файлів з заголовку. Назву буде ігноровано, якщо вона не містить достатньо слешів щоб вдовольнити опції \fB\-p\fR \fIчисло\fR  або \fB\-\-strip=\fR\fIчисло\fR. Назва  \fB/dev/null \fR також ігнорується. 

.br
  *  Якщо присутній рядок  \fBIndex: \fR серед передуючого тексту і якщо нова і стара назва файлу відсутні або  \fBpatch\fR узгоджено з POSIX, тоді  \fBpatch\fR візьме назву з рядка \fBIndex:\fR . 
.br
  *  Для наступних правил, можливі назви файлів вважаються упорядкованими  (старий, новий, індекс), незалежно від того як вони з'являються у заголовку. 

Потім  \fBpatch\fR вибирає назву файлу з\-поміж списку кандидатів наступним чином: 

.br
  *  Якщо деякі з названих файлів існують,  \fBpatch\fR вибере першу назву, якщо встановлена узгодженість з POSIX, і найкращу назву у протилежному випадку. 

.br
  *  Якщо  \fBpatch\fR не ігнорує RCS, ClearCase і SCCS (дивіться опції  \fB\-g \fR \fIчисло\fR  або \fB\-\-get=\fR\fIчисло\fR), і жодного з вказаних файлів не  існує, зате знайдено RCS, ClearCase, або SCCS master,  \fBpatch \fR вибере перший вказаний файл з RCS, ClearCase, або SCCS master. 

.br
  *  Якщо вказаного файлу не було знайдено, так само як  RCS, ClearCase або  SCCS master,  \fBpatch \fR не узгоджено з POSIX і латка, схоже, створить новий файл,  \fBpatch \fR вибере найкращу назву, яка вимагає створення найменшої кількості  тек. 

.br
  *  Якщо жодної назви файлу не видобуто завдяки вище наведеної евристики,  \fBpatch \fR спитає вас назву файлу. 

Для того щоб вибрати найкращу назву зі списку назв файлів, \fBpatch \fR спочатку розглядає всі назви з найменшою кількістю складових, серед них  вибирає ті, що мають найкоротшу базову назву (basename), серед базових назв  також вибирається найкоротша і, накінець, вибір падає першу з назв серед тих  що залишились.  

Додатково, якщо сміття напочатку латки містить рядок  \fBPrereg:\fR , \fBpatch \fR прочитає перше слово з цього рядка необхідних умов (як правило, номер версії)  і перевірить оригінальний файл, щоб виявити чи містить він це слово. Якщо ні,  \fBpatch \fR спитає підтвердження перед тим як діяти. 

Як результат вищесказаного, ви можете, знаходячись у переглядачі новин скажімо,  видати команду на зразок: 

.RS
.nf
 | patch \-d /usr/src/local/blurfl

.fi
.RE
і залатати теку  \fIblurfl \fR безпосередньо з допису у новинах. 

Якщо файл латки містить більше ніж одну латку,  \fBpatch \fR намагатиметься вжити кожну з них так, ніби вони надійшли з різних файлів латок. Це також означає, що назву оригіналу для латання доведеться вгадати для кожного списку diff і, що непотріб перед кожним списком diff містить цікаві речі, такі як назви файлів і  рівень модифікації, як було вказано вище.

.SH " КЛЮЧІ "
.PP

.SS "\-b"  або  "\-\-backup"

.PP

Створює резервні копії. Тобто, під час латання файлу, змінить назву оригіналів або скопіює їх, замість видалити. Якщо оригінального файлу до цього не існувало, буде створено пустий, нечитаємий резервний файл як заповнювач. Подивіться опцію  \fB\-V \fR або  \fB\-\-version\-control\fR ,  щоб дізнатися як визначаються імена резервних копій. 

.SS "\-\-backup\-if\-mismatch"

.PP

Створить резервну копію, якщо латка не повністю співпала з файлом і не було вказано робити резервних копій. Це стандартне поводження, хіба patch відповідає POSIX. 

.SS "\-\-no\-backup\-if\-mismatch"

.PP

Не створює резервну копію, якщо латка не повністю співпала з файлом і не було вказано робити резервних копій. Це поводження \fBpatch\fR ,  узгодженого з POSIX. 

.SS "\-B" \fIпрефікс\fR або "\-\-perfix="\fIпрефікс\fR

.PP

Добавляє  \fIпрефікс \fR до назви файлу під час створення резервної копії. Наприклад з  \fB\-B\fR \fIjunk\fR, простою резервною копією для  \fIsrc/patch/util.c \fR буде  \fI/junk/src/patch/util.c\fR . 

.SS "\-\-binary"

.PP

Читатиме і записуватиме всі файли у бінарному стані, за винятком стандартного виводу і  \fB/dev/tty\fR .  Ця опція не діє на системах, що дотримуються стандарту POSIX і має зміст лише на системах на зразок DOS, де можна вжити  \fBdiff \-a \-\-binary\fR . 

.SS "\-c"  або  "\-\-context"

.PP

Розглядатиме латку як звичайний контекстний diff. 

.SS "\-d" \fIтека\fR або "\-\-directory="\fIтека\fR

.PP

Перейти у \fIтеку\fR негайно, перед тим як здійснити щось. 

.SS "\-D" \fIозначення\fR  або  "\-\-ifdef="\fIозначення\fR

.PP

Використати  \fB#ifdef  ... #endif \fR конструкцію для позначення змін, з  \fIозначенням\fR у якості диференційного (розрізнювального) символу. 

.SS "\-\-dry\-run"

.PP

Вивести лише результат застосування латки, але не латати в  дійсності файл. 

.SS "\-e"   або   "\-\-ed"

.PP

Розглядати латку як скрипт  \fBed\fR . 

.SS "\-E"   або  "\-\-remove\-empty\-files"

.PP

Видалити вихідні файли, якщо вони виявились пустими після вживання латки. Звичайно, ця опція не потрібна, оскільки  \fBpatch \fR сам може розглянути часові мітки в заголовках, щоб вирішити чи файл повинен існувати після латки. Тим не менш, коли ввід не являється контекстним diff або  \fBpatch \fR слідує POSIX, порожні файли не видаляються, якщо цієї опції не було вказано.  Під час видалення файлу, також відбувається спроба усунути порожні каталоги в яких вони знаходились.  

.SS "\-f"  або  "\-\-force"

.PP

Припустити, що користувач знає що робить і не задавати зайвих питань. Пропускати латки, чиї заголовки не вказують який файл залатати; латати файли, навіть якщо вони мають неправильну версію для рядка  \fBPrereq: \fR латки; припустити що латки не відбулися у зворотньому напрямку, навіть якщо  виглядає на те. Ця опція не пригнічує коментарі, використайте  \fB\-s \fR для цього. 

.SS "\-F" \fIчисло\fR або "\-\-fuzz="\fIчисло\fR

.PP

Встановити долю можливої похибки. Ця опція стосується лише diff з доданим контекстом (контекстні diff), і спричиняє до ігнорування певної кількості рядків що не співпадають при пошуку patch місця  запису куска. Зауважте, що більший фактор похибки також збільшує ризик невірної латки. Стандартна доля похибки дорівнює 2 і не може бути встановленою більше ніж кількість рядків контексту у контекстному diff, звичайно \- 3. 

.SS "\-g" \fIчисло\fR або \-\-get=\fIчисло\fR

.PP

Ця опція керує діями  \fBpatch\fR ,  коли файл знаходиться під контролем RCS або SCCS але відсутній або має  дозвіл тільки на читання,  одночасно співпадаючи з версією за  замовчуванням, або файл знаходиться під контролем ClearCase але відсутній.  Якщо  \fIчисло\fR є додатковим,  \fBpatch \fR добуде файл з системи контролю над модифікаціями (revision control system,  RCS). Якщо  \fIчисло \fR дорівнює 0, \fBpatch \fR ігнорує RCS, ClearCase і SCCS і не добуває файлу. Якщо  \fIчисло \fR від'ємне,  \fBpatch\fR  спитає користувача чи добувати файл. Значення для цієї опції можна  встановити через змінну середовища  \fBPATCH_GET\fR ;  якщо її не встановлено, типовим значенням буде 0, коли  \fBpatch \fR узгоджено з POSIX і від'ємне у протилежному випадку.  

.SS "\-\-help"

.PP

Виведе підсумок опцій і вийде. 

.SS "\-i" \fIфайл\fR або "\-\-input="\fIфайл\fR

.PP

Читати  \fIфайл \fR як файл латки. Якщо аргумент  \fIфайл \fR опушений, читатиме зі стандартного вводу. 

.SS "\-l"  або  "\-\-ignore\-whitespace"

.PP

Приблизне співпадання зі зразками, у випадку якщо табуляція або пробіли прийшли в безладдя у ваших файлах. Будь\-яка послідовність одного або більше пропусків у файлі латки співпадають з будь\-якою послідовністю оригіналу. Пропуски в кінці рядків буде ігноровано. Звичайні знаки, тим не менш, повинні збігатись точно. Кожний рядок контексту повинен все ще співпадати з рядком з оригінального файлу. 

.SS "\-n"  або  "\-\-normal"

.PP

Розглядати латку як звичайний diff. 

.SS "\-N"  або  "\-\-forward"

.PP

Ігнорувати латки що здаються оберненими (у оберненому напрямку) або вже вжитими. 

.SS "\-o" \fIфайл_виводу\fR або "\-\-output="\fIфайл_виводу\fR

.PP

Послати вивід до  \fIфайлу_виводу\fR ,  замість латати той самий файл. 

.SS "\-p"\fIчисло\fR або  "\-\-strip="\fIчисло\fR

.PP

Очистить найменший префікс що втримує  \fIчисло \fR передуючих слешів з кожної назви файлу, знайденої у файлі латки.  Послідовність однієї або більше суміжних слешів розглядається як  один слеш. Це керує тим як назви файлів, знайдених у латці, обробляються, у випадку, якщо ви зберігаєте ваші файли у відмінній директорії від тої, в якій їх зберігала особа, яка надіслала латку.  Наприклад, скажімо назва файлу у латці була 

.RS
.nf

/u/howard/src/blurfl/blurfl.c

.fi
.RE

тоді встановлення  \fB\-p0 \fR залишить назву файлу незмінною, тоді як  \fB\-p1 \fR видасть 

.RS
.nf

u/howard/src/blurfl/blurfl.c

.fi
.RE

тобто видалить перший слеш, а  \fB\-p4 \fR вкаже назву  

.RS
.nf

blurfl/blurfl.c

.fi
.RE

Якщо не вказувати  \fB\-p \fR взагалі, ви отримаєте  \fIblurfl.c\fR .  Вказана таким чином назва файлу буде шукатись або в поточному каталозі, або в каталозі, вказаному опцією  \fB\-d\fR .  

.SS "\-\-posix"

.PP

Слідує точніше стандарту POSIX, а саме: 
.br

.br
 
." .sp 

&bull; Візьме перший існуючий файл зі списку (старий, новий, індекс) під час спроби вгадати назви файлів з заголовків diff. 
.br

.br

&bull; Не видалятиме порожні файли після латання.
.br

.br

&bull; Не питатиме чи добувати файли з RCS, ClearCase або SCCS.
.br

.br

&bull; Не робитиме резервних копій файлів у випадку неспівпадання.  

.SS "\-\-quoting\-style=" \fIслово\fR

.PP

Використати стиль  \fIслово \fR під час виводу назв (файлів).  \fIСлово\fR ,  що описує стиль може бути одним з наступних: 

.SS "litelal"

.PP

Виводить назви такими, які вони є. 

.SS "shell"

.PP

Екранує назви для оболонки, якщо вони містять метазнаки, або можуть викликати неоднозначний вивід. 

.SS "shell\-always"

.PP

Екранує назви для оболонки, навіть якщо вони не вимагають того. 

.SS "c"

.PP

Екранує назви, як для ланцюжка мови C. 

.SS "escape"

.PP

Екранує, схоже до попереднього  \fBc\fR ,  але без навколишніх подвійних лапок. 

Ви можете задати аргумент  \fB\-\-quoting\-style \fR у змінній середовища \fBQUOTING_STYLE\fR .  Якщо ця змінна не встановлена, значенням за узгодженням буде  \fBshell\fR .  

.SS "\-r" \fIrejectfile\fR  або  "\-\-reject\-file="\fIrejectfile\fR

.PP

Помістить відкинуті латки у вказаний вами файл \fIrejectfile\fR,  замість стандартного  \fB.rej\fR . 

.SS "\-R"  або  "\-\-reverse"

.PP

Припустити що латка була створена зі старим і новим файлом поміняними місцями. (Так, це час від часу стається, ми не досконалі.)  \fBpatch\fR спробує переставити місцями кожний кусок, перед тим як записати їх. (Тобто рядки, що починалися з \fB+\fR будуть починатися з \fB-\fR, і навпаки.) Відкинуті куски також будуть записані до  \fB.rej \fR у переставленому форматі. Опція  \fB\-R \fR не працює з латками у формі скрипта для  \fBed\fR ,  оскільки вони  надають замало інформації для створення обернутої латки.  
Якщо перший кусок латки зазнав невдачі,  \fBpatch \fR обертає кусок, щоб побачити, чи можливо його вжити таким способом. Якщо,  так, вас спитають, чи ви не хочете встановити опцію \fB\-R\fR .  У протилежному випадку,  \fBpatch \fR продовжує як звичайно. (Примітка: ця метода ме може виявити обернуту латку  у випадку звичайного diff і якщо першою командою стоїть конкатенація,  оскільки долучення до файлу завжди матиме успіх (завдячуючи тому фактові,  що нульовий контекст співпадає зі всім). На щастя, більшість латок додають  або змінюють рядки, замість вилучати їх, тож більшість обернутих латок  починаються з команди вилучення, яка зазнає невдачі і викликає дану евристику.) 

.SS "\-s"  або  "\-\-silent"  або  "\-\-quiet"

.PP

Діє безмовно, хіба станеться помилка. 

.SS "\-t"  або  "\-\-batch"

.PP

Пригнічує запитання, схоже до  \fB\-f\fR ,  але з деякими відмінними умовами: не бере до уваги латки, чиї заголовки не  містять назв файлів (схожа цим до  \fB\-f\fR );  пропускає латки, якщо версія файлу не співпала з рядком  \fBPrereq: \fR у латці; припускає, що латки обернуті, якщо вони такими виглядають. 

.SS "\-T"  або  "\-\-set\-time"

.PP

Встановить час модифікації і доступу до обробленого файлу рівним часовим міткам, знайденим у контекстних заголовків diff, припускаючи, що контекстні заголовки diff використовують локальний час. Ця опція не рекомендується, оскільки латки з використанням локального часу не завжди можуть бути використані тими, що мешкають у відмінних часових поясах, також тому, що локальний час може бути двозначним у випадку переходу на літній час. Замість вживання цієї опції, краще створюйте латки з UTC (Координованим Універсальним Часом) і використовувати опцію  \fB\-Z \fR або \fB\-\-set\-utc \fR з  \fBpatch \fR натомість. 

.SS "\-u"  або  "\-\-unified"

.PP

Вважати файл латки уніфікованим контекстним diff. 

.SS "\-v"  або  "\-\-version"

.PP

Вивести заголовок з датою оновлення програми \fBpatch \fR і рівень латок і вийти. 

.SS "\-V" \fIметода\fR  або  "\-\-version\-control="\fIметода\fR

.PP

Використати вказану  \fIметоду \fR для надання назв резервним копіям. Метода також може бути вказаною у  змінній середовища  \fBPATCH_VERSION_CONTROL \fR (або, якщо останню не встановлено \-  \fBVERSION_CONTROL\fR ),  яка буде  переважена, тим не менш, цією командною опцією. Метода не впливає  на те, чи здійснюється резервне копіювання, чи ні \- тільки на те як резервні копії буде названо.  
Значення, що може надаватися  \fIметоді \fR схожі до відповідних значень змінної GNU Emacs 'version\-control';  \fBpatch \fR також розпізнає наочніші синоніми. Чинними назвами  \fIметод \fR є (можуть бути також унікальні скорочення):  

.SS "existing"  або  "null"

.PP

Здійснює нумеровані копії файлів, що вже мають резервні копії, у протилежному випадку \- звичайні копії. Ця метода використовувана за замовчуванням. 

.SS "numbered"  або  "t"

.PP

Створить нумеровані резервні копії. Назва резервної копії файлу \fIF\fR виглядатиме як \fIF\fR.~\fIN\fR~, де \fIN\fR \- це номер версії. 

.SS "simple"  або  "never"

.PP

Здійснює прості резервні копії. Прапорці \fB\-B \fR або  \fB\-\-prefix\fR ,  \fB\-Y\fR або \fB\-\-basename\-prefix \fR і  \fB\-z \fR або  \fB\-\-suffix \fR вказують як назвати звичайну резервну копію. Якщо жоден з цих прапорців не  вказано, тоді використовується суфікс простого резервування, знайдений у  змінній середовища  \fBSIMPLE_BACKUP_SUFFIX\fR ,  або  \fB.orig\fR ,  якщо її не встановлено. 

У випадку  \fBnumbered \fR або  \fBsipmple\fR ,  резервних копій, якщо назва копії виявиться занадто довгою, буде використано  просто суфікс  \fB~\fR .  Якщо навіть \fB~ \fR утворює занадто довгу назву, тоді  \fB~ \fR візьме місця останньої літери назви файлу. 

.SS "\-\-verbose"

.PP

Виводить додаткову інформацію про здійснюване. 

.SS "\-x" \fIчисло\fR або "\-\-debug="\fIчисло\fR

.PP

Встановлює внутрішні прапорці зневадження програми  \fBpatch\fR .  Цікаве лише розробникам  \fBpatch\fR . 

.SS "\-Y" \fIпрефікс\fR or "\-\-basename\-prefix="\fIпрефікс\fR

.PP

Добавить вказаний префікс до основного імені файлу під час створення простої резервної копії. Прикладом, опція  \fB\-Y .del/ \fR для простої резервної копії файлу  \fIsrc/patch/util.c\fR ,  створить  \fIsrc/patch/.del/util.c\fR . 

.SS "\-z" \fIсуфікс\fR або "\-\-suffix="\fIсуфікс\fR

.PP

Використає  \fIсуфікс \fR як суфікс простої резервної копії. Наприклад,  \fB\-z \fR \- для простої резервної копії файлу \fIsrc/patch/util.c\fR ,  створить   \fIsrc/patch/util.c\-\fR .  Суфікс резервного копіювання можна також вказати у змінній середовища  \fBSIMPLE_BACKUP_SUFFIX\fR ,  яка буде переважена, тим не менш, цією командною опцією. 

.SS "\-Z"  або  "\-\-set\-utc"

.PP

Встановить час модифікації і доступу обробленого файлу до значень міток часу, знайдених у контекстних заголовках diff, за умови, що ці заголовки використовують формат Координованого Універсального Часу (UTC, згадуваного також як GMT). Дивіться також опцію  \fB\-T \fR або \fB\-\-set\-time\fR . 
Опції  \fB\-Z \fR або  \fB\-\-set\-utc \fR так само як  \fB\-T \fR або  \fB\-\-set\-time\fR ,  як правило, втримуються від зміни часових характеристик, якщо оригінальний  час  файлу не співпадає зі вказаним у заголовку латки або, якщо зміст файлу не цілком співпадає з тим, що в латці. Проте, якщо надати \fB\-f \fR або  \fB\-\-force \fR опції, час буде змінено беззастережно.   

.SH "СЕРЕДОВИЩE"
.PP
Наступні змінні середовища впливатимуть на роботу \fBpatch\fR:
.TP
.B PATCH_GET
 Вказує чи повинен \fBpatch\fR видобувати відсутні або тільки для читання файли з RCS, ClearCase або SCCS за замовчуванням. Дивіться також опцію \fB\-g\fR або \fB\-\-get\fR.
.TP
.B POSIXLY_CORRECT
 Якщо її встановлено, \fBpatch\fR слідує точніше стандарту POSIX за замовчуванням. Дивіться також опцію \fB\-\-posix\fR.
.TP
.B QUOTING_STYLE
 Значення за замовчуванням для опції \fB\-\-quoting\-style\fR.Спосіб залапковування і екранації.
.TP
.B SIMPLE_BACKUP_SUFFIX
 Суфікс, що додається до звичайних резервних копій, замість \fB.orig\fR.
.TP
.B TMPDIR ,  TMP ,  TEMP
 Каталог для розміщення тимчасових файлів. \fBpatch\fR використовує першу ж встановлену змінну середовища з цього списку. Якщо жодної не було встановлено, каталог тимчасових файлів є системозалежним; звичайно, це \fI/tmp\fR у Юніксах.

.SS "VERSION_CONTROL"  або  "PATCH_VERSION_CONTROL"

.PP
Вибирає стиль контролю версій файлів. Дивіться опції \fB\-v\fR або \fB\-\-version\-control\fR.

.SH " ФАЙЛИ "
.PP

.SS  
\fI$TMPDIR\fR"/p*"

.PP
тимчасові файли

.SS  
"/dev/tty"

.PP
контрольний термінал; використовується, щоб отримати відповіді на запитання, задані користувачеві

.SH " ДИВІТЬСЯ ТАКОЖ "
.PP
\fBdiff\fR(1), \fBed\fR(1)

Запропонований Marshall T. Rose і Einar A. Stefferud, Стандарт 
Герметизації Повідомлень. Internet RFC 934
<ftp://ftp.isi.edu/in\-notes/rfc934.txt> (1985\-01).

.SH " ПРИМІТКА ДЛЯ ВІДПРАВНИКІВ ЛАTOK"
.PP
Існує декілька речей, які варто мати на увазі перед тим як 
відправляти латки куди інде.

Створюйте власні латки, дотримуючись певної системи. Хорошою
методою вважається команда \fBdiff \-Naur\fR \fIстара нова\fR, де
\fIстара\fR і  \fIнова\fR вказують на відповідні стару і нову теку (до змін і після
змін). Назви \fIстарої\fR і \fIнової\fR не повинні містити жодних слешів.
Заголовки, генеровані командою diff, повинні містити дату і час
у UTC і традиційному форматі Юнікс, тож отримувач латки в змозі
буде використати опції \fB\-Z\fR або \fB\-\-set\-utc\fR. 
Ось приклад, використовуючи синтаксис оболонки Bash:

.RS
.nf
 LC_ALL=C TZ=UTC0 diff \-Naur gcc\-2.7 gcc\-2.8

.fi
.RE
Поясніть отримувачам як застосувати латку, вказуючи в яку
директорію перейти і які опції \fBpatch\fR вжити. Рекомендованою є
опція \fB\-Np1\fR. Перевірте латки на власній системі, вдаючи ніби ви є отримувачем. 

Ви можете запобігти багатьом нещастям, якщо зберігатимете файл \fIpatchlevel.h\fR, 
який лататиметься для збільшення рівня латки як перший diff у файлі 
латки, яку ви відправите. Також, якщо добавити рядок \fBPrereq:\fR 
до латки, це не дозволить застосувати латку в неправильній послідовності 
без звісток про помилки.

Ви можете створювати нові файли якщо відішлете diff, що порівнює \fI/dev/null\fR 
або порожній файл, датований Epoch  (1970\-01\-01 00:00:00 UTC) до файлу, 
який ви хочете створити. Це спрацює лише у тому випадку, якщо файлу, який 
ви хочете створити, ще не існує у каталозі призначення.
І навпаки, ви можете видалити файл, якщо пошлете контекстний diff,
який порівнює файл до вилучення з порожнім файлом датованим Epoch.
Файл буде видалено, хіба patch слідує POSIX і не були вказані
опції \fB\-E\fR або \fB\-\-remove\-empty\-files\fR. 
Легшим способом створення і видалення файлів є використання прапорців \fB\-N\fR та \fB\-\-new\-file\fR, які надає GNU \fBdiff\fR.

Якщо від отримувача очікується вживання опції \fB\-p\fR\fIN\fR, не посилайте 
латок, що виглядають як:

.RS
.nf
 diff \-Naur v2.0.29/prog/README prog/README
 \-\-\- v2.0.29/prog/README   Mon Mar 10 15:13:12 1997
 +++ prog/README   Mon Mar 17 14:58:22 1997

.fi
.RE
оскільки ці дві назви файлів включають різну кількість слешів і
різні версії \fBpatch\fR 
можуть інтерпретувати ці назви файлів по\-різному. Щоб запобігти плутанини, 
вишліть латку, що виглядатиме як наступне:

.RS
.nf
 diff \-Naur v2.0.29/prog/README v2.0.30/prog/README
 \-\-\- v2.0.29/prog/README   Mon Mar 10 15:13:12 1997
 +++ v2.0.30/prog/README   Mon Mar 17 14:58:22 1997

.fi
.RE
Уникайте створення латок, що порівнюють резервні файли, наприклад \fIREADME.orig\fR, 
так як це може заплутати \fBpatch\fR і залатати резервний файл замість дійсного. Натомість 
використовуйте латки, що порівнюють ту саму основну назву але у різних каталогах, наприклад 
\fIold/README\fR і \fInew/README\fR.

Будьте обережними не посилати обернуті латки, оскільки це заставляє
людей серйозно задуматись, чи вони застосували вже латку, чи ні.

Намагайтесь, щоб ваші латки не змінювали похідні файли (наприклад, файл \fIconfigure\fR, 
маючи рядок \fBconfigure: configure.in\fR у вашому \fImakefile\fR), 
оскільки отримувач має змогу генерувати похідні файли самостійно. Якщо ви 
вимушені змінювати похідні файли, створюйте diff, використовуючи UTC і 
вкажіть користувачам вжити \fB\-Z\fR або \fB\-\-set\-utc\fR опції, так само як видалити 
будь\-які незалатані файли, що залежать від латаних (наприклад, командою \fBmake clean\fR).

Навіть якщо ви можете помістити 582 різних diff у один файл,
буде розумнішим розділити споріднені латки у окремі файли у
випадку як щось піде не так як заплановано.

.SH " ДІАГНОСТИКА  "
.PP
Діагностичні повідомлення, як правило, вказують на те, що  \fBpath\fR не в змозі був обробити або зрозуміти вашу латку. 

Якщо надана опція  \fB\-\-verbose\fR ,  повідомлення, що починається з  \fBHmm...\fR вказує на те, що у тексті латки існує ще не оброблений текст і що \fBpatch \fR намагається вгадати, чи це дійсно латка і якщо так, то яка саме. 

Статус виходу  \fBpatch \fR буде 0, якщо всі відрізки вдалося застосувати, 1 \- якщо ні і 2 у випадку  серйозніших несправностей. Під час застосування латок у циклі,  \fBpatch \fR підказує вам перевірити статус виходу, тож вам не доведеться пізніше вжити  іншу латку на частково залатаному файлі. 

.SH " ЗАСТЕРЕЖЕННЯ "
.PP
Контекстуальні diff не надто надійні для створення або вилучення  порожніх файлів, порожніх каталогів чи спеціальних файлів, таких як  символічні посилання, наприклад. Так само вони не справляються зі змінами метаданих файлів, таких як належність, дозволи і чи є файл жорстким посиланням на інший файл. Якщо вищевказані зміни також необхідні, тоді варто супроводжувати латку ще й оболонковим скриптом для цього. 

\fBpatch \fR не в змозі розрізнити чи рядки зміщені у випадку скрипту  \fBed\fR ,  так само може виявити помилковий порядок рядків у звичайному diff лише якщо знайде зміни у тексті або вилучення. Контекстуальний diff зi степінню неточності 3 може потерпувати від того самого. До тих  пір, доки не буде втілено більш\-менш задовільний інтерактивний інтерфейс, намагайтесь вживати контекстуальні diff у таких випадках, щоб впевнитись, що зміни були чинними. Звичайно, компіляція без помилок є досить непоганим покажчиком того, що латка спрацювала, але не завжди. 

\fBpatch\fR ,  загалом, видає вірні результати, навіть якщо йому доводиться здійснювати багато вгадувань. Тим не менш, результат гарантовано правильний лише у випадку, коли латку наставлено на точно ту саму версію файлу, з якої саму латку було створено. 

.SH " ПИТАННЯ СУМІСНОСТІ "
.PP
Стандарт POSIX описує поведінку, яка відрізняється від традиційного поводження \fBpatch\fR .  Ви повинні зважати на ці відмінності, якщо вимушені використовувати \fBpatch \fR версії 2.1 або старшої, які не відповідають стандартові POSIX. 

.br
  *  У традиційному  \fBpatch\fR ,  аргументи опції  \fB\-p \fR не були обов'язковими і просто  \fB\-p \fR дорівнювало  \fB\-p0\fR .  На сьогодення, опція  \fB\-p \fR вимагає аргументу і  \fB\-p 0 \fR є еквівалентним  \fB\-p0\fR .  Для покращеної сумісності, використовуйте ці опції як  \fB\-p0 \fR і  \fB\-p1\fR. Також традиційний \fBpatch \fR просто рахував слеші під час видалення префіксу назв шляхів; \fBpatch \fR тепер вираховує складові назв шляхів. Тобто, послідовність з одного або  більше суміжних слешів вважається одним слешом. Для сумісності зі старими  версіями, уникайте використання латок, що містять  \fB// \fR у назвах файлів. 

.br
  *  У традиційному  \fBpatch\fR ,  резервне копіювання було ввімкнене за замовчуванням. Тепер потрібно  добавляти  \fB\-b \fR або  \fB\-\-backup \fR опції. І, навпаки, у \fBpatch\fR ,  що слідує POSIX, резервні копії ніколи не робляться, навіть якщо відбулося  неспівпадання. У  \fBpatch \fR від GNU такого поводження можна добились лише опцією \fB\-\-no\-backup\-if\-mismatch\fR або ввімкнувши сумісність з POSIX опцією  \fB\-\-posix\fR або через встановлення змінної середовища  \fBPOSIXLY_CORRECT\fR. Опція \fB\-b \fR \fIсуфікс\fR  традиційного \fBpatch \fR є еквівалентною опції  \fB\-b \-z \fR \fIсуфікс\fR GNU  \fBpatch\fR . 

.br
  *  Традиційний  \fBpatch \fR використовував складну (і не досить документовану) методу вгадування назв  файлів для обробки з заголовку латки. Ця метода не узгоджувалась з POSIX і  містила декілька пасток для незнаючих. Тепер  \fBpatch\fR використовує відмінну, так само складну (але документовану) методу, яка,  якщо бажано, може бути POSIX\-сумісною. Ми сподіваємось, вона містить менше  пасток. Ці дві методи сумісні у випадку, якщо назви файлів у заголовку  контекстного diff і рядку  \fBIndex: \fR співпадають після вилучення префіксу. Ваша латка, як правило, сумісна, якщо назви файлів у кожному заголовку містять рівне число слешів. 

.br
  *  Під час задання питань користувачеві, традиційний \fBpatch \fR посилав питання до пристрою стандартної помилки і очікував надходження  відповіді з одного з: стандартної помилки, стандартного виводу,  \fI/dev/tty \fR і стандартного вводу. Тепер patch посилає питання на стандартний вивід і очікує відповіді на  \fI/dev/tty\fR .  Деякі відповіді за замовчуванням помінялись, тож \fBpatch \fR не опиняється у нескінченному циклі після використання стандартної відповіді. 

.br
  *  Статус виходу традиційного \fBpatch \fR дорівнював кількості поганих кусків, або 1, у випадку серйознішої помилки.  Тепер  \fBpatch \fR виходить із статусом 1, якщо деякі куски не співпали і 2 у випадку важливішої помилки.  

.br
  *  Намагайтесь обмежитись наступними опціями, якщо посилаєте інструкції по застосуванню латки будь\-ким, хто використовує GNU \fBpatch\fR, традиційний \fBpatch\fR або POSIX\-сумісний \fBpatch\fR. Пробіли є важливими у наступному списку і аргументи обов'язковими: 
.br

.br
 
." .sp 
\fB\-c  \fR
.br
 \fB\-d \fR \fIкаталог\fR
.br
\fB\-D \fR \fIозначення\fR
.br
\fB\-e\fR
.br
\fB\-l\fR
.br
\fB\-n\fR
.br
\fB\-N\fR
.br
\fB\-o \fR \fIвихідний_файл\fR
.br
\fB\-p\fR \fIчисло\fR
.br
\fB\-R\fR
.br
\fB\-r\fR  \fIrejectfile\fR

.SH " НЕДОЛІКИ "
.PP
Будь ласка, доповідайте про помилки на <bug\-gnu\-utils@gnu.org>. 

\fBpatch \fR міг би бути розумнішим щодо часткових співпадань, занадто великих  зміщень рядків і поміняного місцями коду. Але це забиратиме більше часу. 

Якщо код випадково дубльовано (наприклад шляхом  \fB#ifdef\fR \fIСТАРИЙ_КОД\fR ... \fB#else\fR ... \fB#endif\fR),  \fBpatch \fR неспроможний залатати обидві версії, і навіть якщо так, то скоріш за все  залатає помилкову. Тож будьте уважними. 

Якщо ви застосовує латку, яка все була вжита,  \fBpatch \fR думає, що це обернута латка, надаючи вам таким чином можливість скасувати  останню латку. Це можна розглядати як своєрідна риса програми. 

.SH " АВТОРСЬКІ ПРАВА "
.PP
Copyright 1984, 1985, 1986, 1988 Larry Wall. Copyright  1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc. 

Permission is granted  to  make  and  distribute  verbatim copies  of  this  manual provided the copyright notice and this permission notice are preserved on all copies. 

Permission is granted to copy and distribute modified versions  of  this  manual  under the conditions for verbatim copying, provided that the entire resulting  derived  work is  distributed  under  the  terms  of a permission notice identical to this one. 

Permission is granted to copy and distribute  translations of this manual into another language, under the above conditions  for modified versions, except that this permission notice  may  be  included  in translations approved by the copyright holders instead of in the original English.  

\-\-\-\-
Переклад: Віталій Цибуляк <vi@uatech.atspace.com>

