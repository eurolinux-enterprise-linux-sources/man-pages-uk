." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "strcpy" "3" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

." STRCPY 3 Lіnux Programmer's Manual 

.SH "НАЗВА"
.PP
strcpy, strncpy \- копіює рядок

.SH "ВИКОРИСТАННЯ"
.PP
\fB#іnclude <string.h>\fR

\fBchar *strcpy(char *\fR\fIdest\fR\fB, const char *\fR\fIsrc\fR\fB);\fR

\fBchar *strncpy(char *\fR\fIdest\fR\fB, const char *\fR\fIsrc\fR\fB, size_t\fR \fIn\fR\fB);\fR

.SH "ОПИС"
.PP
Функція \fBstrcpy()\fR копіює рядок, на який вказує \fIsrc\fR
(включаючи кінцевий символ '\e0'), у масив, на який вказує
\fIdest\fR. Рядки не можуть перекриватися і рядок що
утвориться, на який вказує dest, повинен мати досить місця
для копії.

Функція \fBstrncpy()\fR працює аналогічно, за винятком того
копіюється не більше перших \fIn\fR байтів рядка \fIsrc\fR. Таким
чином, якщо в \fIn\fR байтах рядка \fIsrc\fR немає нульового байта, то
отриманий рядок не буде закінчуватися символом ' '.

Якщо довжина \fIsrc\fR менша за \fIn\fR, то зайве місце в \fIdest\fR
заповниться нулями.

.SH "ПРИКЛАДИ"
.PP
Наступне надасть \fIcharray\fR значення "abc\e0\e0\e0":

.RS
.nf
 (void)strncpy(charray, "abc", 6);

.fi
.RE
Наступний приклад встановить \fIcharray\fR як "abcdef" без
нульового закінчення, оскільки копійований рядок >=
параметра довжини масиву. \fBstrncpy()\fR може надати нульове
закінчення лише у випадку коли копійований рядок менший за
параметр довжини.

.RS
.nf
 (void)strncpy(charray, "abcdef", 6);

.fi
.RE
Нижче наведено приклад у якому ми копіюємо стільки знаків,
скільки це можливо з \fIinput\fR до \fIbuff\fR і вручну добавляємо
'\e0' в кінці, оскільки немає надії що \fBstrncpy()\fR завершить
рядок належним чином.

.RS
.nf
 char buf[BUFSIZE];

 (void)strncpy(buf, input, sizeof(buf) \- 1);
 buf[sizeof(buf) \- 1] = '\e0';

.fi
.RE
Зауважте, що \fBstrlcpy\fR(3) буде кращим вибором для таких
ситуацій. Той самий вираз з використанням \fBstrlcpy()\fR буде
виглядати просто як:

.RS
.nf
 (void)strlcpy(buf, input, sizeof(buf));

.fi
.RE

.SH "ПОВЕРНЕНІ ЗНАЧЕННЯ"
.PP
Функції \fBstrcpy()\fR і \fBstrncpy()\fR повертають покажчик на рядок
\fIdest\fR, отриманий в результаті.

.SH "ВАДИ"
.PP
Якщо в новоствореному рядку недостатньо місця для операції
\fBstrcpy()\fR (це буває, якщо недосвідчений або лінивий
програміст не перевірив розміру перед копіюванням), то
може статися все що завгодно. Переповнення рядків сталої
довжини є улюбленою технікою крекерів.

.SH "ВІДПОВІДНІСТЬ СТАНДАРТАМ"
.PP
SVID 3, POSIX, BSD 4.3, ISO 9899

.SH "ДИВІТЬСЯ ТАКОЖ"
.PP
\fBbcopy\fR(3), 
\fBmemccpy\fR(3), 
\fBmemcpy\fR(3), 
\fBmemmove\fR(3), 
\fBwcscpy\fR(3),
\fBwcsncpy\fR(3)

\-\-\-\-
Переклав українською Віталій Цибуляк <vi@uatech.atspace.com>

