." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "gets" "3" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

.SH "НАЗВА"
.PP
fgetc,  fgets,  getc,  getchar, gets, ungetc \- функції для вводу символів і ланцюжків

.SH "СТИСЛИЙ ОГЛЯД"
.PP
\fB#іnclude <stdio.h>\fR

\fBіnt fgetc(FІLE *\fR\fIstream\fR\fB);\fR
.br

\fBchar *fgets(char *\fR\fIs\fR\fB, int\fR \fIsize\fR\fB, FІLE *\fR\fIstream\fR\fB);\fR
.br

\fBіnt getc(FІLE *\fR\fIstream\fR\fB);\fR
.br

\fBint getchar(void);\fR
.br

\fBchar *gets(char *\fR\fIs\fR\fB);\fR
.br

\fBіnt ungetc(іnt\fR \fIc\fR\fB, FІLE *\fR\fIstream\fR\fB);\fR

.SH "ОПИС"
.PP
\fBfgetc()\fR зчитує наступний символ з потоку \fIstream\fR і повертає
його  перетвореним  у \fBunsigned  char\fR,  зведенним до \fBint\fR, або
константу \fBEOF\fR по досягненні кінця файлу або помилці.

\fBgetc()\fR схожа на \fBfgetc()\fR, але вона може  бути  реалізованою
як  макрос,  що  оцінюватиме  поступлення  з потоку \fIstream\fR більше
одного разу.

\fBgetchar()\fR є тим самим що й \fBgetc(\fR\fIstdin\fR\fB)\fR.

\fBgets()\fR зчитує рядок з \fIstdin\fR і записує  його  у  буфер,  на
який  вказує покажчик \fIs\fR,  поки не зустрінеться символ нового рядка
або \fBEOF\fR, що  замінюються  на  '\e0'.   Жодної  перевірки  на
переповнення буфера не відбувається (дивіться \fBВАДИ\fR нижче).

\fBfgets()\fR зчитує щонайбільше \fIsize\fR - 1 символів  з  \fIstream\fR  і заносить їх у  буфер,  на  який  вказує покажчик \fIs\fR.   Читання
переривається якщо досягнуто \fBEOF\fR або символу нового рядка.
Якщо  зчитано  символ  нового  рядка,  то він заноситься в
буфер.  Наприкінці  рядка  завжди  додається   '\e0'   після
останнього зчитаного знаку.

\fBungetc()\fR  заносить  c  назад у \fIstream\fR, і перетворюватиме у
\fBunsigned  char\fR,  якщо  це  можливо  у  подальших  операцій
читання.  Занесені  назад  символи  будуть  повертатися  в
зворотному порядку;  гарантується  тільки  одне  занесення
символів.

Виклики  функцій,  описаних  тут,  можуть перемежовуватись
одне з одним і  з  викликами  до  інших  функцій  вводу  з
бібліотеки \fBstdio\fR для того самого потоку вводу.

Стосовно       неблокуючих       функцій,       подивіться
\fBunlocked_stdio\fR(3).

.SH "ПОВЕРНЕНІ ЗНАЧЕННЯ"
.PP
\fBfgetc()\fR, \fBgetc()\fR і \fBgetchar()\fR повертають  прочитаний  символ
як  \fBunsigned  char\fR,  перетворений  до  \fBint\fR,  або  \fBEOF\fR  при
досягненні кінця файлу або помилці.

\fBgets()\fR  і  \fBfgets()\fR  повертають  при   вдалому   завершенні
операції  і  NULL,  якщо  сталася  помилка   або досягнуто
кінець  файлу  із,  тоді  як  решта  символів   залишились
непрочитаними.

\fBungetc()\fR  повертає c при вдалій операції або \fBEOF\fR у випадку
помилки.

.SH "ВІДПОВІДНІСТЬ СТАНДАРТАМ"
.PP
ANSI \- C, POSIX.1

.SH "ВАДИ"
.PP
Ніколи не застосовуйте \fBgets()\fR, тому  що  без  попереднього
знайомства   з  даними  неможливо  взнати,  яку  кількість
символів  отримає  \fBgets()\fR,  а  також   тому,   що   \fBgets()\fR
продовжуватиме  заносити  символи  в  буфер  навіть  після
досягнення його кінця,  що  дуже  небезпечно.  Ця  функція
використовується    для    злому   систем.   Замість   неї
скористайтеся \fBfgets()\fR.

Hе  рекомендовано  чергувати  виклики  функцій   вводу   з
бібліотеки  \fBstdio\fR  з  низькорівневими викликами \fBread()\fR для
дескриптора файлу, зв'язаного з потоком  вводу;  результат
цього  буде  невизначеним  і,  швидше  за  все, не тим, що
очікується.

Наступний кусочок коду демонструє випадок, коли програміст
припускає,  що  рядок  занадто довгий, якщо він не містить
символ нового рядка:

.RS
.nf
              char buf[1024], *p;

              while (fgets(buf, sizeof(buf), fp) != NULL) {
                  if ((p = strchr(buf, '\en')) == NULL) {
                      fprintf(stderr, "input line too long.\en");
                      exit(1);
                  }
                  *p = '\e0';
                  printf("%s\en", buf);
              }

.fi
.RE
Не дивлячись на те, що помилка буде  дійсною,  якщо  рядок
перевишуватиме  1023  знаки,  вона  не  справдиться у двох
інших випадках:

# Якщо останній рядок  у  файлі  не  містить  символа нового  рядка,  то  рядок,  який поверне \fBfgets()\fR не міститиме  також.  Тож  \fBstrchr()\fR  поверне  \fBNULL\fR і програма  завершить свою дію, навіть якщо рядок був чинним.
# Всі пов'язані  з  рядками  функції  у  C,  \fBstrchr()\fR включно,  правильно  припускають що кінець ланцюжка вказується як  знак  NULL  ('\e0').  Якщо  б першим повернутим знаком був  '\e0', \fBstrchr()\fR би негайно повернула  значення  і  завершила   програму, без розгляду решти вводу, у якому дійно міг знаходитись знак нового рядка.

Можливо функція \fBfgetln\fR(3)  підходить  краще  для  випадків небезпечного вводу.

.SH "ДИВІТЬСЯ ТАКОЖ"
.PP
\fBread\fR(2),  \fBwrite\fR(2), \fBfopen\fR(3), \fBfread\fR(3), \fBscanf\fR(3), \fBputs\fR(3),
\fBfseek\fR(3), \fBferror\fR(3)

\-\-\-\-
Перклав Віталій Цибуляк <vi@uatech.atspace.com>

