." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "scanf" "3" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

." SCANF 3 2006-06-08 Linux "Linux Programmer's Manual" 

.SH "Назва"
.PP
scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf \- функції форматованого вводу 

.SH "Стисло"
.PP
\fB#include <stdio.h>\fR
.br

\fBint scanf(const char *\fR\fIformat\fR\fB, ...);\fR
.br

\fBint fscanf(FILE *\fR\fIstream\fR\fB, const char *\fR\fIformat\fR\fB, ...);\fR
.br

\fBint sscanf(const char *\fR\fIstr\fR\fB, const char *\fR\fIformat\fR\fB, ...);\fR

.RS
.nf
  

.fi
.RE
\fB#include <stdarg.h>\fR
.br

\fBint vscanf(const char *\fR\fIformat\fR\fB, va_list\fR \fIap\fR\fB);\fR
.br

\fBint vsscanf(const char *\fR\fIstr\fR\fB, const char *\fR\fIformat\fR\fB, va_list\fR \fIap\fR\fB);\fR
.br

\fBint vfscanf(FILE *\fR\fIstream\fR\fB, const char *\fR\fIformat\fR\fB, va_list\fR \fIap\fR\fB);\fR

.SH "Опис"
.PP
Сімейство функцій \fBscanf\fR зчитує ввід відповідно до формату, описаного нижче. Формат може містити вказівники перетворення; результати такого перетворення зберігаються у аргументах\-покажчиках. Функція \fBscanf\fR читає ввід зі стандартного потоку вводу \fIstdin\fR, функція \fBfscanf\fR зчитує його з покажчика на потік \fIstream\fR, тоді як \fBsscanf\fR читає ввід з символьного ланцюжка, на який показує \fIstr\fR. 

Функція \fBvfscanf\fR є аналогічною \fBvfprintf\fR(3) і зчитує ввід із покажчика на потік \fIstream\fR, використовуючи змінний список аргументів\-покажчиків (дивіться \fBstdarg\fR(3)). Функція \fBvscanf\fR сканує змінний список аргументів зі стандартного вводу, а функція \fBvsscanf\fR читає його з ланцюжка; вони аналогічні \fBvprintf\fR і \fBvsprintf\fR, відповідно. 

Кожний наступний аргумент\-покажчик повинен відповідати попередньому вказівникові перетворення (але подивіться "пригнічування" нижче). Всі перетворення вводяться зі знаком % (знак проценту). Ланцюжок формату може також містити інші знаки. Пропуски (такі як пробіл, табуляція або новий рядок) у ланцюжку формату співпадають  будь\-якою кількістю пропусків у вводі, включаючи жодний. Решта співпадає тільки саме з собою. Сканування припинено, якщо введений знак не співпадає з форматом, а також, коли перетворення вводу неможливо здійснити (дивіться нижче). 

.SH "Перетворення"
.PP
За символом % можуть слідувати наступні знаки, як вказівники перетворення: 

.TP
.B \fB*\fR
 Скасовує присвоєння нового значення покажчику. Наступне перетворення відбудеться як звичайно, але без використання покажчика; результат перетворення просто вивільняється. 

.TP
.B \fBa\fR
 (glibc) Вказує, що перетворення буде таким самим, що й у випадку \fBs\fR, необхідну для ланцюжка пам'ять буде відведено за допомогою \fBmalloc\fR і покажчик на неї присвоєно покажчиковій змінній типу \fBchar\fR, яку не потрібно попередньо ініціювати. Цей прапорець не існує в ANSI C (C89) і має відмінне значення в C99. 

.TP
.B \fBa\fR
 (C99) Рівнозначний \fBf\fR. 

.TP
.B \fBh\fR
 Вказує на те, що перетворення буде одним з \fBdioux\fR або \fBn\fR і, що наступний покажчик вказує на \fBshort int\fR (замість \fBint\fR). 

.TP
.B \fBl\fR
 Вказує на те, що перетворення буде одним з \fBdioux\fR або \fBn\fR і, що наступний покажчик вказує на \fBlong int\fR (замість \fBint\fR) або, що перетворення буде одним з \fBefg\fR і наступний покажчик вказує на \fBdouble\fR (замість \fBfloat\fR). Вказування двох прапорців \fBl\fR рівнозначне прапорцю \fBL\fR. 

.TP
.B \fBL\fR
 Вказує на те, що перетворення буде або одним з \fBefg\fR і наступний покажчик вказує на \fBlong double\fR, або перетворення буде одним з \fBdioux\fR і наступний покажчик вказує на \fBlong long\fR. (Зауважте, що \fBlong long\fR не є типом, що відповідає ANSI C. Програми, що використовують його не будуть портабельними на різноманітні архітектури.) 

.TP
.B \fBq\fR
 Рівнозначний \fBL\fR. Цього прапорця не існує в ANSI C. 

До цих прапорців можна також додати вказівник максимальної ширини поля у вигляді десяткового цілого, розміщений між % і перетворенням. Якщо ширину не задано, вона буде необмеженою (з одним виключенням, описаним нижче), у протилежному випадку, щонайбільше вказане число знаків зчитуються при перетворенні. Перед початком перетворень пропускаються пробіли, вони не зараховуються до ширини поля. 

Наявні наступні перетворення: 

.TP
.B \fB%\fR
 Співпадає з буквальним `%'. Тобто, `%%' у ланцюжку формату співпадає з єдиним `%' у вводі. Власне перетворення не відбувається, так само як і присвоєння. 

.TP
.B \fBd\fR
 Співпадає з десятковим цілим із можливим знаком; наступний покажчик повинен бути типу \fBint\fR. 

.TP
.B \fBD\fR
 Рівнозначний \fBld\fR; існує лише для оберненої сумісності. (Примітка: це тільки в libc4. В libc5 і glibc, %D мовчки ігнорується, спричиняючи загадкову відмову від роботи старих програм.) 

.TP
.B \fBi\fR
 Співпадає з цілим з можливим знаком; наступний покажчик повинен бути типу \fBint\fR. Ціле буде прочитано у шістнадцятковій системі числення, якщо воно починається з `0x' або `0X' і у вісімковій, якщо з `0', у протилежному випадку \- у десятковій. 

.TP
.B \fBo\fR
 Співпадає з беззнаковим вісімковим цілим; наступний покажчик повинен вказувати на \fBunsigned int\fR. 

.TP
.B \fBu\fR
 Співпадає з беззнаковим десятковим цілим; наступний покажчик повинен вказувати на \fBunsigned int\fR. 

.TP
.B \fBx\fR
 Співпадає з беззнаковим шістнадцятковим цілим; наступний покажчик повинен вказувати на \fBunsigned int\fR. 

.TP
.B \fBX\fR
 Еквівалентний \fBX\fR. 

.TP
.B \fBf\fR
 Співпадає з числом з плаваючою точкою з можливим знаком; відповідний аргумент повинен бути типу \fBfloat\fR. 

.TP
.B \fBe\fR
 Еквівалентний \fBf\fR. 

.TP
.B \fBg\fR
 Еквівалентний \fBf\fR. 

.TP
.B \fBE\fR
 Еквівалентний \fBf\fR. 

.TP
.B \fBs\fR
 Співпадає з послідовністю знаків не\-пробілів; відповідний аргумент повинен бути типу \fBchar\fR, і масив повинен бути додатньо великим, щоб вмістити всю послідовність і кінцевий NULL\-символ. Зчитування ввідного ланцюжка припиниться при першому ж пропуску або ж досягненні максимальної ширини поля. 

.TP
.B \fBc\fR
 Співпаде з послідовністю вказаної кількості знаків (за замовчуванням 1); відповідний аргумент повинен бути покажчиком типу \fBchar\fR, і мати достатньо місця, щоб вмістити всі знаки (кінцевий NULL не додається). Звичний пропуск пробілу не відбувається. Щоб пропустити передуючий пробіл, додайте явний пробіл до ланцюжка формату. 

.TP
.B \fB[\fR
 Співпадає з послідовністю знаків зі вказаного всередині квадратних дужок набору дозволених; відповідний аргумент повинен бути покажчиком типу \fBchar\fR, і мати додстатньо місця для всіх знаків ланцюжка з кінцевим NULL\-символом. Звичний пропуск пробілу не відбувається. Ланцюжок складатиметься зі знаків, включених в (або виключених з) певний набор знаків; набір означено знаками між відкриваючою \fB[\fR і закриваючою \fB]\fR. Набір виключатиме ці знаки, якщо першим в наборі стоїть \fB^ .\fR Щоб включити квадратну дужку в набір, зробіть її першим знаком за відкриваючою квадратною дужкою або \fB^\fR; будь\-яка інша позиція завершить набір. Знак риски \fB\-\fR також спеціальний; якщо добавити його між двома іншими знаками, це додає всі проміжні знаки (набору ASCII). Щоб включити буквальну риску, зробіть її останнім знаком перед закриваючою квадратною дужкою. Наприклад, "[^]0\-9\-]" означає "все, окрім правої квадратної дужки, чисел від нуля до дев'яти і риски". Зчитування ланцюжка завершиться як тільки буде знайдено знак, що не належить наборові (або у випадку \fB^\fR, навпаки, належить) або ж коли досягнуто максимальної ширини поля. 

.TP
.B \fBp\fR
 Співпадає з покажчиковим значенням (як виводиться "%p" у \fBprintf\fR(3)); відповідний аргумент повинен бути покажчиком на \fIvoid\fR. 

.TP
.B \fBn\fR
 Нічого не очікується, натомість кількість прочитаних знаків вводу буде збережено у відповідному аргументові, який повинен бути покажчиком типу \fBint\fR. Це не являється перетворенням, хоча його можна блокувати прапорцем \fB*\fR. Стандарт C каже, що "виконання %n не приростає відлік символів по завершенню виконання", але Поправка (Corrigendum), схоже суперечить цьому. Напевне, розсудливішим буде не робити якихось припущень щодо ефекту перетворень %n. 

.SH "Повернені значення"
.PP
Ці функції повертають кількість присвоєних елементів, що може виявитись меншим ніж вказано прочитати, або навіть жодного у випадку неспівпадання. Нуль означає, що навіть при присутності ввідних даних, жодного перетворення не було присвоєно; типово це відбувається через недійсний введений символ, скажімо літера алфавіту для перетворення "%d". \fBEOF\fR повертається, якщо невдача вводу мала місце до того, як відбулась якась проба перетворення, як скажімо при досягненні кінця файлу. Якщо перетворення відбулося до того, як виникла помилка або досягнуто кінця файлу, повертається число успішних перетворень. 

.SH "Відповідність стандартам"
.PP
Функції \fBfscanf\fR, \fBscanf\fR і \fBsscanf\fR відповідають ANSI X3.159\-1989 ("ANSI C"). 

Прапорець \fBq\fR \- це нотація BSD 4.4 для типу \fBlong long\fR, тоді як \fBll\fR або використання літери \fBL\fR в перетвореннях цілих \- це нотація GNU. 

Лінукс\-версія цих функцій основано на бібліотеці libio GNU. Загляніть до info\-документації libc GNU (glibc\-1.08) для точнішого опису. 

.SH "Вади"
.PP
Всі функції повністю узгоджуються з ANSI X3.159\-1989, але надають додаткові прапорці \fBq\fR так само як додаткове поводження прапорців \fBL\fR і \fBl\fR. Останнє може вважатися вадою, оскільки це змінює поводження прапорців, визначених стандартом ANSI X3.159\-1989. 

Деякі прапорці, означені ANSI C не мають змісту в самому ANSI C (наприклад %Ld), зате добре визначене поводження в Лінуксі, але не на всіх архітектурах. Тому іноді краще використовувати прапорці, не визначені ANSI C, тобто \fBq\fR замість \fBL\fR у комбінації з перетвореннями \fBdiouxX\fR або \fBll\fR. 

Використання \fBq\fR не співпадає з відповідним у BSD 4.4, так як цей прапорець можна застосувати для перетворення чисел з плаваючою точкою тотожно \fBL\fR. 

.SH "Дивіться також"
.PP
\fBstrtol\fR(3), \fBstrtoul\fR(3), \fBstrtod\fR(3), \fBgetc\fR(3), \fBprintf\fR(3)

." Переклав Віталій Цибуляк (tech@oboz.com.ua) 

