." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "printf" "3" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

." PRINTF 3 2006-06-06 Linux "Linux Programmer's Manual" 

.SH "Назва"
.PP
printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf \- функції форматування виводу 

.SH "Огляд"
.PP
\fB#include <stdio.h>\fR 

\fBint printf(const char *\fR\fIformat\fR\fB, ...);\fR 

.br

\fBint fprintf(FILE *\fR\fIstream\fR\fB, const char *\fR\fIformat\fR\fB, ...);\fR 

.br

\fBint sprintf(char *\fR\fIstr\fR\fB, const char *\fR\fIformat\fR\fB, ...);\fR 

.br

\fBint snprintf(char *\fR\fIstr\fR\fB, size_t \fR\fIsize\fR\fB, const char *\fR\fIformat\fR\fB, ...);\fR 

\fB#include <stdarg.h>\fR 

\fBint vprintf(const char *\fR\fIformat\fR\fB, va_list \fR\fIap\fR\fB);\fR 

.br

\fBint vfprintf(FILE *\fR\fIstream\fR\fB, const char *\fR\fIformat\fR\fB, va_list \fR\fIap\fR\fB);\fR 

.br

\fBint vsprintf(char *\fR\fIstr\fR\fB, const char *\fR\fIformat\fR\fB, va_list \fR\fIap\fR\fB);\fR 

.br

\fBint vsnprintf(char *\fR\fIstr\fR\fB, size_t \fR\fIsize\fR\fB, const char *\fR\fIformat\fR\fB, va_list \fR\fIap\fR\fB);\fR 

.SH "Опис"
.PP
Функції з сімейства \fBprintf\fR створюють вивід відповідно формату, описаного нижче. Функції \fBprintf\fR і \fBvprintf\fR пишуть свій вивід до \fIstdout\fR, стандартного потоку виводу; \fBfprintf\fR і \fBvfprintf\fR пишуть свій вивід до заданого їм потоку виводу; \fBsprintf\fR, \fBsnprintf\fR, \fBvsprintf\fR і \fBvsnprintf\fR пишуть до символьного ланцюжка \fIstr\fR. 

Функції \fBvprintf\fR, \fBvfprintf\fR, \fBvsprintf\fR i \fBvsnprintf\fR еквівалентні функціям \fBprintf\fR, \fBfprintf\fR, \fBsprintf\fR і \fBsnprintf\fR, відповідно, за винятком того, що вони вживаються з \fBva_list\fR замість змінної кількості аргументів. Ці функції не викликають макросу \fBva_end\fR, тож значення \fIap\fR буде невизначеним після виклику. Додатки повинні самі покликати \fBva_end(\fR\fIap\fR\fB)\fR в кінці. 

Ці вісім функцій здійснюють вивід відповідно до ланцюжка форматування, який описує як саме аргументи, що слідують один за одним (або аргументи, доступні завдяки засобам обробки змінної кількості аргументів \fBstdarg\fR(3)) перетворено для виводу. 

.SS " Повернені значення "
.PP
У випадку вдалого виконання, ці функції повертають кількість виведених знаків (виключаючи завершальний '\e0', використовуваний для закінчення виводу ланцюжків). Функції \fBsnprintf\fR і \fBvsnprintf\fR не записують більше ніж \fIsize\fR байтів (завершальний '\e0', включно). Якщо вивід урізано, завдяки цьому обмеженню, тоді поверненим значенням буде число знаків (без кінцевого '\e0'), яке було би виведено як остаточний ланцюжок, якби було би достатньо місця. Таким чином, повернене значення, рівне \fIsize\fR або більше, означає, що вивід урізано. (Подивіться також коментар у \fBПРИМІТКАХ\fR.) Якщо відбулася помилка виводу, повертається від'ємне значення. 

.SS " Формат форматувального ланцюжка "
.PP
Форматувальний ланцюжок відповідає за зовнішній вигляд виводу. Він складається з нуля або більше директив: звичайних знаків (без %), які копійовано без змін до вивідного потоку і описувачі перетворення, кожному з яких відповідає один аргумент пізніше. Кожен описувач перетворення починається зі знаку % і закінчується літерою\-вказівником перетворення, між якими можуть знаходитись (у наведеній послідовності) нуль або більше прапорців, необов'язковий вказівник ширини поля, необов'язковий вказівник точності і довжини. 

Вимагається належна відповідність між аргументами (після переведення типу) й опусувачами перетворення. Типово, аргументи використовуються у заданому порядку, де `*' у кожному описувачі перетворення запитує наступний аргумент (і відбудеться помилка, якщо вказано недостатньо аргументів). Ви можете також явно вказати, який аргумент взяти там де вимагається аргумент, записом `%\fIm\fR$' замість `%' і `*\fIm\fR$' замість `*', де десяткове ціле \fIm\fR означає положення бажаного аргументу у списку аргументів; індексація починається з 1. Таким чином, 

.RS
.nf
    	printf("%*d", width, num);

.fi
.RE
і

.RS
.nf
    	printf("%2$*1$d", width, num);

.fi
.RE
являються еквівалентними. Другий стиль нотації дозволяє повторні звернення до того самого аргументу. Стандарт C99 не включає використання `$', яке було привнесено з Єдиної Специфікації Юнікса. Якщо використовується стиль з `$', його необхідно вживати скрізь для всіх перетворень з аргументом так само, як усіх вказівників ширини і точності, але його можна перемежовувати з форматом `%%', який не бере жодних аргументів. Не може бути проміжків у кількості вказаних аргументів, використовуючи `$'; наприклад, якщо вказано аргумент 1 і 3, необхідно також десь у ланцюжку вказати й аргумент 2. 

Для деяких числових перетворень використовується десятковий знак або знак угруповування тисяч. Ці знаки залежать від встановленої локалі для змінної середовища \fBLC_NUMERIC\fR. Локаль POSIX використовує крапку `.' як десятковий знак і не має розділювача тисяч. Таки чином, 

.RS
.nf
    	printf("%'.2f", 1234567.89);

.fi
.RE
видасть `1234567.89' у локалі POSIX, `1234567,89' у локалі nl_NL і `1.234.567,89' у da_DK. 

.SS " Прапорці "
.PP
За знаком % можуть слідувати нуль або більше наступних прапорців: 

.TP
.B \fB#\fR
 Значення потрібно обернути у "альтернативну форму". У випадку \fBo\fR\-перетворень, першим знаком ланцюжка виводу буде нуль (додаючи 0, якщо там його ще немає). Для \fBx\fR і \fBX\fR\-перетворень, ланцюжок буде починатися з `0x' (або `0X' для \fBX\fR\-перетворень). Для перетворень \fBa\fR, \fBA\fR, \fBe\fR, \fBE\fR, \fBf\fR, \fBF\fR, \fBg\fR й \fBG\fR результат завжди міститиме десяткову крапку, навіть якщо за нею не слідує жодних цифр (за звичайних обставин, десяткова крапка з'являється в цих перетвореннях тільки, якщо присутня десяткові числа). Для \efg\efP і \fBG\fR\-перетворень, хвостові нулі не вилучаються з результату, як це робиться звичайно. Для решти перетворень результат невизначено. 

.TP
.B \fB0\fR
 Значення потрібно заповнити нулями. Для перетворень \fBd,\fR \fBi\fR, \fBo\fR, \fBu,\fR \fBx,\fR \fBX\fR, \fBa\fR, \fBA,\fR \fBe,\fR \fBE\fR, \fBf\fR, \fBF\fR, \fBg\fR й \fBG\fR, вивід заповнюється нулями, а не пробілами, з лівої сторони. Якщо з'являться обидва знаки, \fB0\fR й \fB\-\fR, тоді \fB0\fR ігнорується. Якщо задано вказівник точності числовому перетворенню \fBd\fR, \fBi\fR, \fBo\fR, \fBu\fR, \fBx\fR або \fBX\fR, прапорець \fB0\fR буде ігноровано. Для решти перетворень, поводження не є визначеним. 

.TP
.B \fB\-\fR
 Перетворене значення вирівнюватиметься ліворуч у межах поля. (Стандартним є вирівнювання праворуч.) За винятком \fBn\fR\-перетворень, значення заповнюватимуться пробілами з правої сторони, замість пробілів або нулів зліва, як звичайно. \fBA\fR переважить \fB0\fR, якщо обидва задано. 

.TP
.B \fB. .\fR
 (пробіл) Добавить пробіл перед додатнім числом (або порожнім ланцюжком) у випадку перетворення зі знаком. 

.TP
.B \fB+\fR
 Знак (+ або \-) завжди добавлятиметься попереду числа у перетвореннях зі знаком. Стандартно, знак використовується тільки з від'ємними числами. Прапорець \fB+\fR переважить пробіл, якщо обидва задано. 

П'ять вищенаведених прапорців визначено стандартом C. SUSv2 зазначено ще один прапорець: 

.TP
.B \fB,\fR
 У випадку десяткових перетворень \fBi\fR, \fBd\fR, \fBu\fR, \fBf\fR, \fBF\fR, \fBg\fR, або \fBG\fR, вивід поділятиметься на тисячі знаком поділу, якщо локаль включає такий. Майте на увазі, що багато версії \fBgcc\fR не розпізнають цієї опції і видадуть попередження. SUSv2 не включає %'F. 

glibc 2.2 додало ще один знак прапорця: \fBI\fR У випадку десяткових перетворень \fBi\fR, \fBd\fR, \fBu\fR, застосовуватимуться альтернативні числа виводу для локалі, якщо такі існують. Наприклад, починаючи з glibc 2.2.3, це надасть можливість виводу арабсько\-індійських цифр у перській (fa_IR) локалі. 

.SS " Ширина поля "
.PP
Необов'язковий ланцюжок з десятковим числом (з ненульовим числом, як перша цифра) може вказувати мінімальну ширину поля. Якщо перетворене значення має менше знаків, ніж ширина поля, решту буде заповнено пробілами з лівого боку (або правого, якщо задано прапорець вирівнювання по лівому краю). Замість ланцюжка з десятковим числом, ви можете також написати `*' або `*\fIm\fR$' (з якимось десятковим числом \fIm\fR), щоб вказати ширину поля для наступного аргументу або \fIm\fR\-ному аргументу, відповідно, який повинен бути типу \fBint\fR. Можна вказувати також від'ємне значення для ширини поля. В жодному разі, відсутність ширини поля або занадто мале значення не спричинять обрізання поля; якщо результат перетворення ширше ніж вказана ширина поля, поле буде продовжено, щоб розмістити вивід. 

.SS " Точність "
.PP
Необов'язковий показник точності може складатися з точки (`.') з послідуючим, можливим, ланцюжком з десяткового числа. Замість десяткового числа ви можете написати `*' або `*\fIm\fR$' (з якимось десятковим числом \fIm\fR), щоб вказати ширину поля для наступного аргументу або \fIm\fR\-ному аргументу, відповідно, який повинен бути типу \fBint\fR. Якщо точність задано тільки як `.' або це від'ємне значення, вона вважатиметься нульовою. Вказівник точності вказує мінімальну кількість чисел для перетворень \fBd\fR, \fBi\fR, \fBo\fR, \fBu\fR, \fBx\fR і \fBX\fR або кількість чисел після десяткового знаку у випадку \fBa\fR, \fBA\fR, \fBe\fR, \fBE\fR, \fBf\fR і \fBF\fR\-перетворень, або ж максимальне число символів, що буде виведено, для ланцюжкових перетворень \fBs\fR і \fBS\fR. 

.SS " Модифікатор довжини "
.PP
Тут "перетворення цілих" означає вказівники \fBd\fR, \fBi\fR, \fBo\fR, \fBu\fR, \fBx\fR або \fBX\fR. 

.TP
.B \fBhh\fR
 Наступне перетворення цілих відповідає аргументові, що являє собою ціле зі знаком або ціле без знаку, або наступне \fBn\fR\-перетворення відповідає аргументу\-покажчику на ціле зі знаком. 

.TP
.B \fBh\fR
 Наступне перетворення цілих відповідає короткому цілому або беззнаковому короткому цілому аргументові, або або наступне \fIn\fR\-перетворення відповідає аргументу\-покажчику на коротке ціле. 

.TP
.B \fBl\fR
 (англійська "л") Наступне перетворення цілих відповідає аргументові, що являє собою довге ціле або беззнакове довге ціле, або наступне \ef\eBn\efP\-перетворення відповідає покажчику на довге ціле, або наступне \fBc\fR\-перетворення відповідає аргументові типу \fBwint_t\fR, або наступне \fBs\fR\-перетворення відповідає аргументові типу \fBwchat_t\fR. 

.TP
.B \fBll\fR
 (дві англійські "л") Наступне перетворення цілих відповідає аргументові, що являє собою довге\-довге ціле або беззнакове довге\-довге ціле, або ж наступне \fBn\fR\-перетворення відповідає аргументу\-покажчику на довге\-довге ціле. 

.TP
.B \fBL\fR
 Наступні перетворення \fBa\fR, \fBA\fR, \fBe\fR, \fBE,\fR \fBf\fR, \fBF\fR, \fBg\fR або \fBG\fR відповідають аргументові, що являє собою довге подвійне. (C99 допускає %LF, тоді як SUSv2 \- ні.) 

.TP
.B \fBq\fR
 ("quad". Тільки для BSD 4.4 і Linux libc5. Не використовуйте його.) Синонім \fBll\fR. 

.TP
.B \fBj\fR
 Перетворення цілого, що відповідає аргументові типу \fBintmax_t\fR або \fBuintmax_t\fR. 

.TP
.B \fBz\fR
 Перетворення цілого, що відповідає аргументові типу \fBsize_t\fR або \fBssize_t\fR. (У Linux libc5 використовується \fBZ\fR для цього. Не вживайте його.) 

.TP
.B \fBt\fR
 Перетворення цілого, що відповідає аргументові типу \fBptrdiff_t\fR. 

SUSv2 знає тільки про модифікатори довжини \fBh\fR (у випадках \fBhd\fR, \fBhi\fR, \fBho\fR, \fBhx\fR, \fBhX\fR, \fBhn\fR), модифікатор \fBl\fR (у випадках \fBld\fR, \fBli\fR, \fBlo\fR, \fBlx\fR, \fBlX\fR, \fBln\fR, \fBlc\fR, \fBls\fR) а також \fBL\fR (у випадках \fBLe\fR, \fBLE\fR, \fBLf\fR, \fBLg\fR, \fBLG\fR). 

.SS " Вказівники перетворення "
.PP
Вказівниками перетворення називаються знаки, що вказують на тип застосовуваного перетворення. Ось їхній перелік: 

.TP
.B \fBd\fR, \fBi\fR
 Аргумент типу \fBint\fR перетворено до десяткового запису зі знаком. Точність, якщо така вказана, вказує мінімальне число цифр, що мусить з'явитися; якщо перетворене значення вимагає менше цифр, його заповнено з лівої сторони нулями. Стандартною точністю є 1. При виводі значення 0 зі вказаною точністю 0, нічого не з'явиться. 

.TP
.B \fBo\fR, \fBu\fR, \fBx\fR, \fBX\fR
 Беззнаковий аргумент типу \fBint\fR перетворено до беззнакової вісімкової (\fBo\fR), беззнакової десяткової (\fBu\fR) або беззнакової шістнадцяткової (\fBx\fR, \fBX\fR) нотації. Літери "abcdef" використовуються у випадку \fBx\fR, а "ABCDEF" у випадку \fBX\fR шістнадцяткового перетворення. Точність, якщо задано, вказуватиме мінімальну кількість цифр, що повинна з'явитись; якщо перетворене значення вимагатиме менше цифр, його буде заповнено нулями з лівої сторони. Стандартною точністю є 1. При виводі значення 0 зі вказаною точністю 0, нічого не з'явиться. 

.TP
.B \fBe\fR, \fBE\fR
 Аргумент типу подвійного округлено і виведено у стилі [\-]d.ddd\fBe\fRdd, де буде одна цифра до десяткового знаку і кількість цифр після рівна вказівникові точності; якщо вказівник точності відсутній, використовуватиметься 6; якщо точність дорівнює нулю, десятковий знак не з'являтиметься. Перетворення з \fBE\fR використовує літеру "E" (замість "e") для представлення експоненти. Експонент завжди міститиме щонайменше дві цифри; якщо значення дорівнює нулю, експонент буде зображено як 00. 

.TP
.B \fBf\fR, \fBF\fR
 Аргумент типу подвійного округлено і перетворено у десяткове представлення в стилі [\-]ddd.ddd, де кількість знаків після десяткового знаку дорівнює вказівникові точності. Якщо показник точності відсутній, використовуватиметься 6; якщо ж вказівник точності дорівнює нулю, десятковий знак не з'являтиметься. При появі десяткового знаку, принаймні одна цифра стоятиме попереду нього. 

(SUSv2 не знає про \fBF\fR і обіцяє появу позначення для нескінченності і не\-числа NaN. Стандарт C99 зазначив `[\-]inf' або `[\-]infinity' для нескінченності і ланцюжок, що починається з `nan' для не\-числа NaN у випадку \fBf\fR\-перетворення і, відповідно, `[\-]INF' або `[\-]INFINITY' й `NAN*' \- у випадку перетворення з \fBF\fR.) 

.TP
.B \fBg\fR, \fBG\fR
 Аргумент типу подвійного перетворено до стилю \fBf\fR або \fBe\fR (\fBF\fR і \fBE\fR, відповідно, для \fBG\fR). Вказівник точності зазначає число найважливіших цифр. Якщо вказівник точності відсутній, використовуватиметься 6 цифр; якщо точність дорівнює нулю, вона розглядатиметься як 1. \fBe\fR\-стиль використовується, якщо експонент, після перетворення, менший за \-4 або більший або дорівнює точності. Хвостові нулі вилучаються з дробової частини результату; десяткова точка з'явиться тільки, якщо за нею слідує принаймні одна цифра. 

.TP
.B \fBa\fR, \fBA\fR
 (C99; немає в SUSv2) У випадку \fBa\fR, аргумент типу подвійного перетворено до шістнадцяткового представлення (з використанням літер "abcdef") у стилі [\-]0xh.hhhhpd; у випадку \fBA\fR, використовується префікс 0X, літери "ABSDEF" і розділювач експоненти P. Повинна бути одна шістнадцяткова цифра до десяткової точки і кількість цифр після дорівнює вказівникові точності. Стандартна точність повинна задовольняти правильне представлення числа, якщо правильне представлення в двійковій системі існує, у протилежному випадку, вона буде достатньо великою, щоб розрізняти значення типу подвійного. Цифру до десяткової точки не зазначено не ненормалізованих чисел і не\-нулів, так само не зазначено для нормалізованих чисел. 

.TP
.B \fBc\fR
 Без модифікатору \fBl\fR (англійська "л"), аргумент типу \fBint\fR перетворено до беззнакового символу, \fBunsigned char\fR і, отриманий в результаті знак, виведено. При наявності модифікатору \fBl\fR, аргумент типу \fBwint_t\fR (широкий знак) перетворено до багатобайтової послідовності через виклик функції \fBwcrtomb\fR(3) і, отриманий у результаті знак виведено. 

.TP
.B \fBs\fR
 Без модифікатору \fBl\fR (англійська "л"): очікується, що аргумент типу \fBconst char *\fR є покажчиком на масив знаків (покажчик на ланцюжок). Знаки з цього масиву виводяться аж до (не включаючи) завершуючого знаку NULL; якщо задано точність, виводиться не більше вказаного числа символів. З вказівником точності нульовий знак може бути відсутнім; якщо вказівника точності немає або він більший за розмір масиву, останній повинен містити завершувальний NULL. 

З модифікатором \fBl\fR: очікується, що аргумент типу \fBwchar_t *\fR є покажчиком на масив широких знаків. Широкі знаки з масиву перетворено на багатобайтові знаки (кожний, шляхом виклику функції \fBwcrtomb\fR(3)), аж до завершуючого широкого знаку NULL, включно). Отримані в результаті багатобайтові знаки виводяться до (але не включаючи) завершувального NULL. Якщо задано точність, виводиться не більше вказаного числа символів, але не буде виведено неповного багатобайтового знаку. Зауважте, що точність вказує на кількість виведених байтів, а не широких символів. Масив повинен містити кінцевий широкий NULL, хіба задано точність і її значення менше за кількість байтів масиву. 

.TP
.B \fBC\fR
 (Немає в C99, тільки SUSv2) Синонім \fBlc\fR. Не використовуйте. 

.TP
.B \fBS\fR
 (Немає в C99, тільки SUSv2) Синонім \fBls\fR. Не використовуйте. 

.TP
.B \fBp\fR
 Аргумент типу \fBvoid *\fR виводиться у шістнадцятковому представленні (так ніби вжито %#x або %#lx). 

.TP
.B \fBn\fR
 Кількість виведених до цих пір знаків збережено у ціле, на яке вказує аргумент, що є покажчиком типу \fBint *\fR (або варіантом цього). Перетворення аргументів не відбувається. 

.TP
.B \fB%\fR
 Виводиться %. Перетворення аргументів не відбувається. Повна форма: `%%'. 

.SH "Приклади"
.PP
Виведе pi з точністю 5: 

.RS
.nf
    	#include <math.h>
    	#include <stdio.h>
            fprintf(stdout, "pi = %.5f\en", 4 * atan(1.0));

.fi
.RE
Виводить дату і час у формі "Sunday, July 3, 10:02", де день тижня і місяць \- покажчики на ланцюжки: 

.RS
.nf
    	#include <stdio.h>
            fprintf(stdout, "%s, %s %d, %.2d:%.2d\en",
                             weekday, month, day, hour, min);

.fi
.RE
там де формат залежить від локалі, можна змінити аргументи. Зі значеннями 

.RS
.nf
    	"%1$s, %3$d. %2$s, %4$d:%5$.2d\en"

.fi
.RE
хтось міг би отримати "Sonntag, 3. Juli, 10:02", наприклад. 

Щоб виділити достатньо великий ланцюжок і записати до нього (код правильний для glibc 2.0 і glibc 2.1): 

.RS
.nf
    	#include <stdio.h>
            #include <stdlib.h>
            #include <stdarg.h>
            char *
            make_message(const char *fmt, ...) {
                /* Напевне, нам потрібно більш за 100 байтів.  */
                int n, size = 100;
                char *p;
                va_list ap;
                if ((p = malloc (size)) == NULL)
                    return NULL;
                while (1) {
                    /* Спробуємо записати у відведене місце.   */
                    va_start(ap, fmt);
                    n = vsnprintf (p, size, fmt, ap);
                    va_end(ap);
                    /* Якщо це спрацювало, повернути ланцюжок. */
                    if (n > \-1 && n < size)
                        return p;
                    /* У протилежному випадку, додамо місця і  *
                     * спробуємо знову.                        */
                    if (n > \-1)     /* glibc 2.1          */
                        size = n+1; /* трохи більше       */
                    else            /* glibc 2.0          */
                        size *= 2;  /*  у два рази більше */
                    if ((p = realloc (p, size)) == NULL)
                        return NULL;
                }
            }

.fi
.RE

.SH "Примітки"
.PP
Втілення функцій \fBsnprintf\fR і \fBvsnprintf\fR, які ви знайдете в glibc, відповідає стандартові C99, тобто поводяться так, як описано вище, починаючи з glibc 2.1. Попередньо до glibc 2.0.6, вони повертали \-1, якщо вивід було урізано. 

.SH "Відповідність стандартам"
.PP
Функції \fBfprintf\fR, \fBprintf\fR, \fBsprintf\fR, \fBvprintf\fR, \fBvfprintf\fR і \fBvsprintf\fR відповідають ANSI X3.159\-1989 ("ANSI C") і ISO/IEC 9899:1999 ("ISO C99"). Функції \fBsnprintf\fR і \fBvsnprintf\fR відповідають стандартові ISO/IEC 9899:1999. 

Стосовно поверненого значення \fBsnprintf\fR, SUSv2 і C99 перечать одне одному: якщо \fBsnprintf\fR викликано з size=0, SUSv2 обумовлює повернення невизначеного значення, меншого за 1, тоді як C99 дозволяє ланцюжку бути NULL, у цьому випадку, і повернене значення (як звичайно) дорівнюватиме кількості знаків, яку було би виведено у випадку, якби ланцюжок був би достатньої довжини. 

Linux libc4 знає про п'ять стандартних прапорців C. Знає також про модифікатори довжини \fBh\fR, \fBl\fR і \fBL\fR і перетворення \fBcdeEfFgGinopsuxX\fR, де \fBF\fR є синонімом \fBf\fR. На додаток, бібліотека розпізнає \fBD\fR, \fBO\fR, \fBU\fR, як синоніми \fBld\fR, \fBlo\fR та \fBlu\fR. (Це недобре і спричинило серйозні помилки пізніше, коли підтримка %D зникла.) Не розпізнаються, залежні від локалі, десяткові розділювачі, так само як розділювачі тисяч, NaN, нескінченість, %m$ або *m$. 

Linux libc5 знає про п'ять стандартних прапорців C а також прапорець ', локаль, %m$ та *m$. Вона розпізнає модифікатори довжини \fBh\fR, \fBl\fR, \fBL\fR, \fBZ\fR, \fBq\fR, але приймає \fBL\fR та \fBq\fR для обох довгих подвійних і довгих\-довгих цілих (це є помилкою). libc5 не розпізнає більше \fBFDOU\fR, але додала новий знак перетворення \fBm\fR, який виводить strerror(errno). 

glibc 2.0 додала знаки перетворення \fBC\fR й \fBS\fR. 

glibc 2.1 додала модифікатори довжини \fBhh\fR, \fBj\fR, \fBt\fR, \fBz\fR, а також знаки перетворення \fBa\fR, \fBA\fR. 

glibc 2.2 додала знак перетворення \fBF\fR з семантикою C99, а також прапорець \fBI\fR. 

.SH "Історія"
.PP
Unix V7 визначає три функції: \fBprintf\fR, \fBfprintf\fR і \fBsprintf\fR і має прапорець \fB\-\fR, ширину або точність \fB*\fR, модифікатор довжини \fBl\fR і перетворення \fBdoxfegcsu\fR разом з \fBD\fR, \fBO\fR, \fBU\fR, \fBX\fR, як синоніми \fBld\fR, \fBlo\fR, \fBlu\fR, \fBlx\fR. Це залишається дійсним у BSD 2.9.1, але BSD 2.10 має прапорці \fB#\fR, \fB+\fR й <пробіл> і більше не згадує \fBD\fR, \fBO\fR, \fBU\fR, \fBX\fR. BSD 2.11 має \fBvprintf\fR, \fBvfprintf\fR, \fBvsprintf\fR і застерігає не використовувати \fBD\fR, \fBO\fR, \fBU\fR, \fBX\fR. BSD 4.3 Reno додало прапорець \fB,\fR модифікатори довжини \fBh\fR із \fBL\fR і перетворення \fBn\fR, \fBp\fR, \fBE\fR, \fBG\fR, \fBX\fR (з сучасним значенням) і відкинула \fBD\fR, \fBO\fR, \fBU\fR. BSD 4.4 ввела функції \fBsnprintf\fR і \fBvsnprintf\fR і модифікатор довжини \fBq\fR. FreeBSD має також функції \fBasprintf\fR і \fBvasprintf\fR, які відводять достатньо великий буфер для \fBsprintf\fR. У glibc існують функції \fBdprintf\fR і \fBvdprintf\fR, які здійснюють запис до дескриптору файлу замість потоку. 

.SH "Вади"
.PP
Оскільки \fBsprintf\fR і \fBvsprintf\fR передбачають взаємодію з ланцюжками довільної довжини, необхідно бути обережним, щоб не переповнити дійсний простір; цього, часто, неможливо бути певним. Зауважте, що довжина отриманого ланцюжка може бути локалезалежною і важко передбачуваною. Використовуйте \fBsnprintf\fR і \fBvsnprintf\fR натомість (або \fBasprintf\fR і \fBvasprintf\fR). 

Linux libc4.[45] не має \fBsnprintf\fR, зате включає бібліотеку libbsd, яка містить \fBsnprintf\fR, еквівалентну \fBsprintf\fR, тобто таку, що ігнорує аргумент розміру. Таким чином, використання \fBsnprintf\fR з ранніми версіями libc4 призводить до серйозних проблем з небезпекою. 

Код на кшталт printf(foo) частіше вказує на помилку, оскільки foo може включати знак %. Якщо foo походить з незахищеного користувацького вводу, вона може містити %n, спричиняючи запис до пам'яті і діру у захисті. 

.SH "Дивіться також"
.PP
\fBprintf\fR(1), \fBasprintf\fR(3), \fBdprintf\fR(3), \fBwcrtomb\fR(3), \fBwprintf\fR(3), \fBscanf\fR(3), \fBlocale\fR(5)  

." Переклав Віталій Цубуляк 

