." © 2005-2007 DLOU, GNU FDL
." URL: <http://docs.linux.org.ua/index.php/Man_Contents>
." Supported by <docs@linux.org.ua>
."
." Permission is granted to copy, distribute and/or modify this document
." under the terms of the GNU Free Documentation License, Version 1.2
." or any later version published by the Free Software Foundation;
." with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
." 
." A copy of the license is included  as a file called COPYING in the
." main directory of the man-pages-* source package.
."
." This manpage has been automatically generated by wiki2man.py
." This tool can be found at: <http://wiki2man.sourceforge.net>
." Please send any bug reports, improvements, comments, patches, etc. to
." E-mail: <wiki2man-develop@lists.sourceforge.net>.

.TH "stdarg" "3" "2007-10-27-16:31" "© 2005-2007 DLOU, GNU FDL" "2007-10-27-16:31"

." STDARG 3 2006-06-01 "" "Посібник програміста Лінукса" 

.SH "Назва"
.PP
stdarg \- змінний список аргументів 

.SH "Огляд"
.PP
\fB#include <stdarg.h>\fR

.RS
.nf
    

.fi
.RE
\fBvoid va_start(va_list\fR \fIap\fR\fB,\fR \fIlast\fR\fB);\fR
.br

\fBtype va_arg(va_list\fR \fIap\fR\fB,\fR \fItype\fR\fB);\fR
.br

\fBvoid va_end(va_list\fR \fIap\fR\fB);\fR
.br

\fBvoid va_copy(va_list\fR \fIdest\fR\fB, va_list\fR \fIsrc\fR\fB);\fR

.SH "Опис"
.PP
Функція може бути викликаною з різноманітною кількістю аргументів різноманітних типів. Файл\-заголовок \fIstdarg.h\fR оголошує тип \fBva_list\fR і визначає три макроси для проходження через список аргументів, чия кількість і тип невідомі викликаній функції. 

Викликана функція повинна оголосити об'єкт типу \fBva_list\fR, який використовуватиметься макросами \fBva_start\fR, \fBva_arg\fR і \fBva_end\fR. 

.SS " va_start "
.PP
Макрос \fBva_start\fR ініціалізує \fIap\fR для пізнішого використання \fBva_arg\fR і \fBva_end\fR і повинен бути викликаним першим. 

Параметр \fIlast\fR є назвою останнього параметру перед змінним списком аргументів, тобто останній параметр, чий тип відомий викликаючій функції. 

Оскільки адреса цього параметру може використовуватись у \fBva_start\fR макросі, її не слід оголошувати як регістрова змінна, або як функція, або ж як масивовий тип. 

.SS " va_arg "
.PP
Макрос \fBva_arg\fR розкривається у вираз, що матиме тип і значення наступного аргумету виклику. Параметр \fIap\fR є типу \fBva_list\fR, ініційований \fBva_start\fR. Кожний виклик \fBva_arg\fR змінює \fIap\fR так, що кожний новий виклик повертає наступний аргумент. Параметр \fItype\fR є назвою типу, тож покажчик на об'єкт певного типу можна вказати просто додаючи * за вказаним типом. 

Перше використання макросу \fBva_arg\fR після \fBva_start\fR повертає аргумент, що слідує за останнім відомим аргументом, \fIlast\fR. Послідовні виклики повертають значення решти аргументів. 

Якщо наступний аргумент відсутній або, якщо тип є несумісним з типом дійсного наступного аргументу, відбудеться довільна помилка. 

Якщо \fIap\fR передано функції, що використовує \fBva_arg(\fR\fIap\fR\fB,\fR \fItype\fR\fB)\fR, тоді значення \fIap\fR буде невизначеним після повернення цією функцією. 

.SS " va_end "
.PP
Кожний виклик \fBva_start\fR повинен мати відповідний \fBva_end\fR у тій самій функції. Після виклику \fBva_end(\fR\fIap\fR\fB)\fR змінна \fIap\fR стане невизначеною. Можливі багатократні проходження списків, кожне з яких повинно бути включеним у \fBva_start\fR і \fBva_end\fR. \fBva_end\fR може бути як макросом, так і функцією. 

.SS " va_copy "
.PP
Стандартна реалізація, як правило, має \fBva_list\fR як покажчик на фрейм стеку зміцнювальної функції. При такій (найпоширенішій) схемі, схоже, нічого не заперечує присвоєнню на зразок 

.RS
.nf
        va_list aq = ap;

.fi
.RE
На жаль, існують також системи, які роблять \fBva_list\fR масивом покажчиків (довжиною 1) і де необхідно 

.RS
.nf
        va_list aq;
        *aq = *ap;

.fi
.RE
І, накінець, на системах, де параметри передаються через регістри, може виникнути необхідність виділення пам'яті функцією \fBva_start\fR, збереження там параметрів, крім того вказівник, який параметр є наступним, тож \fBva_arg\fR зможе пройти крізь список. Після чого \fBva_end\fR зможе звільнити виділену пам'ять знову. Щоб задовільнити ці вимоги, C99 додав макрос \fBva_copy\fR, тож присвоєння вище можна замінити на 

.RS
.nf
        va_list aq;
        va_copy(aq, ap);
        ...
        va_end(aq);

.fi
.RE
Кожний виклик \fBva_copy\fR повинен співпадати з відповідним \fBva_end\fR у тій самій функції. Деякі системи, що не надають .BР va_copy , мають \fB__va_copy\fR натомість, оскільки саме ця назва використовувалась у чорновій пропозиції. 

.SH "Приклад"
.PP
Функція sum, яка додає довільну кількість цілих. 

.RS
.nf
        #include<stdarg.h>
        #include<stdio.h>
    
        void sum(char *, int, ...);
    
        int main(void)
        {
            sum("The sum of 10+15+13 is %d.\en", 3, 10, 15, 13);
            return 0;
        }
    
        void sum(char *string, int num_args, ...)
        {
            int sum = 0;
            va_list ap;
            int i;
    
            va_start(ap, num_args);    /* ініціалізація ap */
            for(i = 0; i < num_args; i++)
                sum += va_arg(ap, int); /* проходження ap  *
                                         * через аргументи */
            printf(string, sum);
            va_end(ap);
        }

.fi
.RE
Функція fprint, яка візьме список форматуючих символів і виведе аргументи у відповідності з форматуючим символом, основуючись на типі. 

.RS
.nf
        #include <stdio.h>
        #include <stdarg.h>
    
        void fprint(char *fmt, ...) {
            va_list ap;
            int d;
            char c, *p, *s;
    
            va_start(ap, fmt);
            while (*fmt)
                switch(*fmt++) {
                case 's':           /* ланцюжок */
                    s = va_arg(ap, char *);
                    printf("string %s\en", s);
                    break;
                case 'd':           /* ціле int */
                    d = va_arg(ap, int);
                    printf("int %d\en", d);
                    break;
                case 'c':           /* символ char */
                    /* необхідне зведення типів, оскільки va_arg *
                     * візьме тільки повністю сформований тип    */
                       c = (char) va_arg(ap, int);
                       printf("char %c\en", c);
                       break;
                }
            va_end(ap);
        }

.fi
.RE

.SH "Відповідність стандартам"
.PP
Макроси \fBva_start\fR, \fBva_arg\fR і \fBva_end\fR відповідають ANSI X3.159\-1989 ("C89"). C99 дало визначення макросу \fBva_copy\fR. 

.SH "Сумісність"
.PP
Ці макроси не сумісні з історичними версіями, які вони замінили. Обернено\-сумісну версію можна знайти у заголовковому файлі \fIvarargs.h\fR. 

.SH "Порівняння"
.PP
Історична версія виглядатиме наступним чином: 

.RS
.nf
        #include <varargs.h>
    
        void fprint(va_alist) va_dcl {
            va_list ap;
    
            va_start(ap);
            while(...) {
                ...
                x = va_arg(ap, type);
                ...
            }
            va_end(ap);
        }

.fi
.RE
На деяких системах, \fBva_end\fR містить закриваючу `}', що співпадатиме з відкриваючою `{' \fBva_start\fR, тож обидва макроси повинні знаходитись у тій самій функції і, в якійсь мірі, фігурні дужки примушують до цього. 

.SH "Вади"
.PP
На відміну від макросів \fIvarargs.h\fR, розглянуті тут не дозволяють програмістам кодування функцій без сталих аргументів. Ця проблема додає роботи, головним чином, коли доводиться переводити код varargs до stdarg, але це також створює труднощі у випадку змінювальних функцій, які хочуть передати всі свої аргументи іншій, яка візьме аргументи типу va_list, наприклад \fBvfprintf\fR(3).

